#+TITLE: An Emacs Config
#+AUTHOR: Austin Smith
#+EMAIL: AssailantLF@gmail.com

* Preamble

This is my Emacs config, which is (pretty much) in a single file thanks to
[[http://orgmode.org/worg/org-contrib/babel/intro.html][org-babel]].

Although GitHub does render =.org= files nicely, I recommend viewing it in
Emacs, as GitHub isn't fully compatible. Using org-mode gives a nice overview
and makes it quick and easy to navigate and make changes.

* Package related

Setup general package related settings.

** package.el

Initialize package.el, the built-in package manager.

#+BEGIN_SRC emacs-lisp
  (package-initialize)
#+END_SRC

These are the package repositories I use:

#+BEGIN_SRC emacs-lisp
  (setq package-archives '(("gnu" . "http://elpa.gnu.org/packages/")
                           ("melpa" . "http://melpa.org/packages/")
                           ("melpa-stable" . "http://stable.melpa.org/packages/")))
#+END_SRC

** use-package

Install/activate [[https://github.com/jwiegley/use-package][use-package]], basically a wrapper for =package.el=.

- makes installing and configuring other packages nicer and easier
- helps with autoloading packages to greatly reduce initial startup time

#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
  (require 'use-package)
  (setq use-package-always-ensure t)
#+END_SRC

* Appearance related

Setup appearance early so that if something goes wrong with the init, Emacs is
still lookin' good. These settings (mostly) shouldn't affect any functionality.

** Maximize Emacs on startup

This snippet works in *nix and all (relevant) versions of Windows.

#+BEGIN_SRC emacs-lisp
  (defun w32-maximize-frame ()
    "Maximize the current frame (windows only)"
    (interactive)
    (w32-send-sys-command 61488))
  (if (eq system-type 'windows-nt)
      (progn
        (add-hook 'window-setup-hook 'w32-maximize-frame t))
    (set-frame-parameter nil 'fullscreen 'maximized))
#+END_SRC

** Minimal GUI

Remove unnecessary GUI elements: menu-bar, tool-bar, and scroll-bar.

#+BEGIN_SRC emacs-lisp
  (if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
  (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
#+END_SRC

** No splash screen

Interesting trivia: Emacs originally opened to the scratch buffer by default.

#+BEGIN_SRC emacs-lisp
  (setq inhibit-splash-screen t)
#+END_SRC

** Initial scratch buffer message

#+BEGIN_SRC emacs-lisp
(setq initial-scratch-message "")
#+END_SRC

** Default Font

#+BEGIN_SRC emacs-lisp
  (add-to-list 'default-frame-alist '(font . "DejaVu Sans Mono-9" ))
  (set-face-attribute 'default t :font "DejaVu Sans Mono-9")
#+END_SRC

** STOP THE BEEPING AND FLASHING

#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function 'ignore)
#+END_SRC

** Theme

I've always used dark themes/colorschemes, but I'm trying out [[https://github.com/fniessen/emacs-leuven-theme][Leuven-theme]]
because it looks that good.

#+BEGIN_SRC emacs-lisp
  (use-package leuven-theme
      :init
    ;; (setq leuven-scale-outline-headlines nil)
    :config
    (load-theme 'leuven t))

  ;; (use-package monokai-theme
  ;;      :init
  ;;    (setq monokai-use-variable-pitch nil
  ;;          monokai-height-minus-1 1.0
  ;;          monokai-height-plus-1 1.0
  ;;          monokai-height-plus-2 1.0
  ;;          monokai-height-plus-3 1.0
  ;;          monokai-height-plus-4 1.0)
  ;;    :config
  ;;    (load-theme 'monokai t))
#+END_SRC

** RainbowDelimiters

Highlight matching delimiters with unique colors. It's pretty indespensible
for lisp with all its mad parenthesis.

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :commands (rainbow-delimiters-mode)
    :init
    (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+END_SRC

** Highlight matching parenthesis
Specifically the ones under the cursor.

#+BEGIN_SRC emacs-lisp
  (custom-set-variables '(show-paren-delay 0.0))
  (show-paren-mode t)
#+END_SRC

** Highlight trailing white space

(Only for programming languages)

Trailing white space is something that you hate once you know it's there. Or at
least it is for me.

#+BEGIN_SRC emacs-lisp
  (defun my/buf-show-trailing-whitespace ()
    (interactive)
    (setq show-trailing-whitespace t))
  (add-hook 'prog-mode-hook 'my/buf-show-trailing-whitespace)
  (custom-set-faces '(trailing-whitespace ((t (:background "dim gray")))))
#+END_SRC

** Prettify symbols

Convert certain words into symbols. Prime example: =lambda= becomes =λ=.

#+BEGIN_SRC emacs-lisp
(global-prettify-symbols-mode)
#+END_SRC

** Indicate lines after EOF

Use tildes like Vim :>

#+BEGIN_SRC emacs-lisp
  (define-fringe-bitmap 'tilde [0 0 0 113 219 142 0 0] nil nil 'center)
  (setcdr (assq 'empty-line fringe-indicator-alist) 'tilde)
  (set-fringe-bitmap-face 'tilde 'font-lock-comment-face)
  (setq-default indicate-empty-lines t)
#+END_SRC

** Show column number in modeline

#+BEGIN_SRC emacs-lisp
  (column-number-mode t)
#+END_SRC

** Spaceline

I want to set this up some day because it looks vrry pretty.

#+BEGIN_SRC emacs-lisp
  ;; (use-package spaceline
  ;;     :config
  ;;     (require 'spaceline-config)
  ;;     (spaceline-spacemacs-theme))
#+END_SRC

** SmartModeLine

Mostly makes the mode line easier to read.

#+BEGIN_SRC emacs-lisp
  (use-package smart-mode-line
    :config
    (setq sml/no-confirm-load-theme t)
    (setq sml/theme 'light)
    (sml/setup))
#+END_SRC

** Diminish

Use diminish to clean up the mode line. The mode line is cluttered as heck
without this. I use the =:diminish= key word for =use-package= when I can.

#+BEGIN_SRC emacs-lisp
  (use-package diminish
    :config
    (eval-after-load "hideshow" '(diminish 'hs-minor-mode))
    (eval-after-load "undo-tree" '(diminish 'undo-tree-mode))
    (eval-after-load "simple" '(diminish 'overwrite-mode))
    (eval-after-load "autorevert" '(diminish 'auto-revert-mode)))
#+END_SRC

* General settings

These settings don't belong to any specific mode or package. Some packages are
exceptional for being very simple.

** Start server if it isn't started

Turn the first Emacs process into a server, which allows reuse of a that process
through the shell command =emacsclient=.

#+BEGIN_SRC emacs-lisp
  (require 'server)
  (if (not (server-running-p)) (server-start))
#+END_SRC

** Backup & auto-save files in one place

These files are useful if something goes wrong, but they're also annoying in how
they clutter directories. Put them in =~/.emacs.d/tmp= to remedy this.

#+BEGIN_SRC emacs-lisp
  (setq backup-directory-alist `((".*" . "~/.emacs.d/tmp"))
        auto-save-file-name-transforms `((".*" , "~/.emacs.d/tmp" t)))
#+END_SRC

** Scroll smoothly

#+BEGIN_SRC emacs-lisp
  (setq scroll-margin 0)
  (setq scroll-conservatively 10000)
  (setq scroll-preserve-screen-position t)
#+END_SRC

** Sentences end with a single period

#+BEGIN_SRC emacs-lisp
  (setq sentence-end-double-space nil)
#+END_SRC

** y/n instead of yes/no

#+BEGIN_SRC emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Wrap text at 80 characters

#+BEGIN_SRC emacs-lisp
  (setq-default fill-column 80)
#+END_SRC

** Indent with spaces by default

Tabs are weird and can have varying lengths, so I prefer spaces.

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
#+END_SRC

** Auto-detect indent settings

I prefer to follow a file's indenting style instead of enforcing my own, if
possible. =dtrt-indent= does this and works for most mainstream languages.

#+BEGIN_SRC emacs-lisp
  (use-package dtrt-indent)
#+END_SRC

** Auto-update changed files

If a file is changed outside of Emacs, automatically load those changes.

#+BEGIN_SRC emacs-lisp
  (global-auto-revert-mode t)
#+END_SRC

** Auto-executable scripts in *nix

When saving a file that starts with =#!=, make it executable.

#+BEGIN_SRC emacs-lisp
(add-hook 'after-save-hook
          'executable-make-buffer-file-executable-if-script-p)
#+END_SRC

** Enable HideShow in programming modes

Useful for getting an overview of the code. It works better in some
languages and layouts than others.

#+BEGIN_SRC emacs-lisp
  (defun my/enable-hideshow ()
    (interactive)
    (hs-minor-mode t))
  (add-hook 'prog-mode-hook 'my/enable-hideshow)
#+END_SRC

** Recent Files

Enable =recentf-mode= and remember a lot of files.

#+BEGIN_SRC emacs-lisp
  (recentf-mode 1)
  (setq recentf-max-saved-items 200)
#+END_SRC

** Better same-name buffer distinction

When two buffers are open with the same name, this makes it easier to tell them
apart.

#+BEGIN_SRC emacs-lisp
(require 'uniquify)
(setq uniquify-buffer-name-style 'forward)
#+END_SRC

** Remember last position for reopened files

#+BEGIN_SRC emacs-lisp
(if (version< emacs-version "25.0")
    (progn (require 'saveplace)
           (setq-default save-place t))
  (save-place-mode 1))
#+END_SRC

** Disable garbage collection in minibuffer

See [[http://tiny.cc/7wd7ay][this article]] for more info.

#+BEGIN_SRC emacs-lisp
(defun my/minibuffer-setup-hook ()
  (setq gc-cons-threshold most-positive-fixnum))
(defun my/minibuffer-exit-hook ()
  (setq gc-cons-threshold 800000))
(add-hook 'minibuffer-setup-hook #'my/minibuffer-setup-hook)
(add-hook 'minibuffer-exit-hook #'my/minibuffer-exit-hook)
#+END_SRC

* Key binding related

These are global bindings, and packages that affect key binding in general.

** Enhanced key binding

[[https://github.com/noctuid/general.el][general.el]] is one of my favorite packages, and makes it much nicer and easier to
bind keys. Particularly useful for Evil mode and its various states.

#+BEGIN_SRC emacs-lisp
(use-package general)
#+END_SRC

** The Mighty Hydra

I'm a big fan of [[https://github.com/abo-abo/hydra][Hydra]]. Search for =defhydra= in this file to check out all my
hydras.

What is a hydra? From the README:

#+BEGIN_QUOTE
This is a package for GNU Emacs that can be used to tie related commands into a
family of short bindings with a common prefix - a Hydra.
#+END_QUOTE

followed by a description for poets:

#+BEGIN_QUOTE
Once you summon the Hydra through the prefixed binding (the body + any one
head), all heads can be called in succession with only a short extension.

The Hydra is vanquished once Hercules, any binding that isn't the Hydra's head,
arrives. Note that Hercules, besides vanquishing the Hydra, will still serve his
original purpose, calling his proper command. This makes the Hydra very
seamless, it's like a minor mode that disables itself auto-magically.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
  (use-package hydra
    :config
    ;; Use a lighter red for my dark backgrounds
    (set-face-foreground 'hydra-face-red "#FF3232"))
#+END_SRC

** Show available key bindings

Use [[https://github.com/justbur/emacs-which-key][which-key]] or [[https://github.com/kai2nenobu/guide-key][guide-key]] to display key bindings. =which-key= is a
superior package, but isn't compatible with older versions of Emacs.

#+BEGIN_SRC emacs-lisp
  (if (version< emacs-version "24.4")
      (use-package guide-key
          :init
        (setq guide-key/guide-key-sequence t
              guide-key/recursive-key-sequence-flag t
              guide-key/popup-window-position 'bottom
              guide-key/idle-delay 0.5)
        :config
        (guide-key-mode 1))
      (use-package which-key
          :diminish ""
          :init
          (setq which-key-idle-delay 0.5
                which-key-side-window-max-height 0.50
                which-key-allow-evil-operators t
                which-key-show-operator-state-maps nil))
      :config
      (which-key-mode)
      ;; show top-level bindings, I don't need the Emacs tutorial
      (general-define-key "C-h t" 'which-key-show-top-level))
#+END_SRC

** Resize text easier

Resize text like every other program does.

#+BEGIN_SRC emacs-lisp
  (defun text-scale-reset ()
    "Reset the text scale to 0."
    (interactive)
    (text-scale-set 0))
  (general-define-key
   "C-0" 'text-scale-reset
   "C-=" 'text-scale-increase
   "C--" 'text-scale-decrease)
#+END_SRC

* Language-specific

** C/C++

coding style preferences:

#+BEGIN_SRC emacs-lisp
    (defun my-case-helper (sym-and-anchor)
      (let* ((new-offset '+) ; if there's nothing after the case colon, just indent by c-basic-offset
             (anchor (cdr sym-and-anchor))
             (anchor-line (line-number-at-pos anchor)))
        (save-excursion
          (goto-char anchor)
          (search-forward-regexp ":[[:space:]]*[^[:space:]{]" nil t)
          ;; did we find non-whitespace (and not just an open brace) after
          ;; the colon on the case line?
          (if (and (> (point) anchor)
                   (= anchor-line (line-number-at-pos)))
              (setq new-offset (- (point) anchor 1)))
          new-offset)))

    (c-add-style "my-style"
                 '("linux"
                   (c-offsets-alist
                    (statement-case-intro . my-case-helper))))

  (setq c-basic-offset 4
        c-default-style
        (quote
         ((c-mode . "my-style")
          (c++-mode . "my-style")
          (java-mode . "java")
          (awk-mode . "awk")
          (other . "gnu"))))

  (c-set-offset 'case-label '+)
#+END_SRC

** lisp

Better indenting.

#+BEGIN_SRC emacs-lisp
  (setq lisp-indent-function 'common-lisp-indent-function)
#+END_SRC

* Setup various packages & modes

** Restart Emacs

Useful because I edit my config frequently

#+BEGIN_SRC emacs-lisp
  (use-package restart-emacs
    :commands (restart-emacs)
    :bind ("C-x C-r" . restart-emacs))
#+END_SRC

** Org-mode

*** Prettier bullets

Automatically hides preceding asterisks, and makes the leading one
pretty.

#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :commands (org-bullets-mode)
  :init
  (setq org-bullets-bullet-list '("●"))
  (add-hook 'org-mode-hook 'org-bullets-mode))
#+END_SRC

*** Noticeable ellipsis

When headers are collapsed, =org-mode= uses ellipses to represent the hidden
text, but I think that's too subtle, so this makes them stand out more.

#+BEGIN_SRC emacs-lisp
  (setq org-ellipsis "•••")
  ;; (setq org-ellipsis " 隠")
#+END_SRC

*** Don't adapt indentation

The hierarchy of headers already does the job that indenting would do.

#+BEGIN_SRC emacs-lisp
(setq org-adapt-indentation nil)
#+END_SRC

*** utf-8 encoding plz

#+BEGIN_SRC emacs-lisp
(setq utf-translate-cjk-mode nil)
(set-locale-environment "pl_PL.UTF-8")
(set-language-environment 'utf-8)
(setq locale-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(unless (eq system-type 'windows-nt)
  (progn
    (set-selection-coding-system 'utf-8)
    (set-keyboard-coding-system 'utf-8-mac)))
(prefer-coding-system 'utf-8)
#+END_SRC

*** More convenient bindings

#+BEGIN_SRC emacs-lisp
  (general-define-key :keymaps 'org-mode-map
                      "C-c C-8" 'org-ctrl-c-star
                      "C-c 8" 'org-ctrl-c-star)
#+END_SRC

*** Global org bindings

These are available everywhere, even outside of org-mode.

#+BEGIN_SRC emacs-lisp
(global-set-key "\C-cl" 'org-store-link)
(global-set-key "\C-cc" 'org-capture)
(global-set-key "\C-ca" 'org-agenda)
(global-set-key "\C-cb" 'org-iswitchb)
#+END_SRC

*** Worf package

Worf is a minor mode for providing vi-like bindings for org-mode. However, I'm
only using it to take advantage of some of its nice functions.

#+BEGIN_SRC emacs-lisp
  (use-package worf)
#+END_SRC

*** [[*Evil Org][Evil-mode compatibility]]

** Dired/Dired+

*** Enable find-alternate-file

Prevents dired from creating an annoying popup when =dired-find-alternate-file=
is called.

#+BEGIN_SRC emacs-lisp
(put 'dired-find-alternate-file 'disabled nil)
#+END_SRC

*** Human readable filesize

#+BEGIN_SRC emacs-lisp
(setq dired-listing-switches "-alh")
#+END_SRC

*** Dired+

#+BEGIN_SRC emacs-lisp
(use-package dired+)
#+END_SRC

*** [[*Evil%20Dired][Evil-mode compatibility]]

** Magit

*** Install/activate

#+BEGIN_SRC emacs-lisp
  (use-package magit
    ;; Autoload related
    :commands (magit-status
               magit-diff
               magit-commit
               magit-log
               magit-push
               magit-stage-file
               magit-unstage-file))
#+END_SRC

*** Magit is slow for Windows

[[https://github.com/magit/magit/issues/2395][WORKAROUND SOURCE]]

In summary: Magit isn't the problem. Git for Windows is just horribly slow with
multiple calls, so these simplified functions make things less painful by
calling less git commands.

#+BEGIN_SRC emacs-lisp
  (use-package magit
      :config
    (when (eq system-type 'windows-nt)
      (define-derived-mode magit-staging-mode magit-status-mode "Magit staging"
                           "Mode for showing staged and unstaged changes."
                           :group 'magit-status)
      (defun magit-staging-refresh-buffer ()
        (magit-insert-section (status)
            (magit-insert-untracked-files)
          (magit-insert-unstaged-changes)
          (magit-insert-staged-changes)))
      (defun magit-staging ()
        (interactive)
        (magit-mode-setup #'magit-staging-mode))))
#+END_SRC

*** Use =ssh-agency= for Windows login prompt

Windows has issues allowing Magit to display prompts (when pushing a repo, for
example), so this package deals with that and fixes it somehow.

#+BEGIN_SRC emacs-lisp
  (use-package ssh-agency
    :after (magit)
    :init
    (setenv "SSH_ASKPASS" "git-gui--askpass"))
#+END_SRC

*** [[*Evil%20Magit][Evil-mode compatibility]]

** Projectile

*** Install/activate

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    ;; Autoload related
    :commands (projectile-global-mode)
    :bind-keymap ("C-c p" . projectile-command-map)

    :config
    (projectile-mode t))
#+END_SRC

*** [[*Evil%20Projectile][Evil-mode compatibility]]

** Ivy

*** Install/activate

#+BEGIN_SRC emacs-lisp
  (use-package swiper
    ;; Autoload related
    :commands (ivy-read)
    :bind (("C-h f" . counsel-describe-function)
           ("C-h v" . counsel-describe-variable)
           ("C-s" . swiper))

    :init
    (setq
     ;; recenter after swiper is finished
     swiper-action-recenter t

     ;; list recent files in buffer list as "virtual"
     ivy-use-virtual-buffers t

     ;; wrap around ivy results
     ivy-wrap t

     ;; use ivy as backend
     magit-completing-read-function 'ivy-completing-read
     projectile-completion-system 'ivy)

    :config
    (ivy-mode 1)
    (diminish 'ivy-mode)

    ;; Adds enhanced ivy versions of many commands
    (use-package counsel)

    ;; A nice ivy hydra
    (use-package ivy-hydra))
#+END_SRC

*** [[*Evil%20Ivy][Evil-mode compatibility]]

** Yasnippet

Snippets are located under the typical =~/.emacs.d/snippets=

#+BEGIN_SRC emacs-lisp
;; (use-package yasnippet
;;   :diminish yas-minor-mode
;;   :config
;;   (yas-global-mode 1))
#+END_SRC

* EVIL-MODE

Evil is so big and important that it gets its own top-level header. In all caps.

I used Vim for a couple years before Emacs (and still do), and that means I'm
cursed/blessed with modal editing for the rest of my life. Fortunately Evil is a
nearly exact Vim implementation, so all is well, and I can take advantage of
both editors with less mental strain.

** Compatibility with other modes

Create a list of functions to be ran when Evil-mode is activated. Each function
corresponds to a mode, and configures that mode to "be more evil."

The benefit of this is that I can enable or disable all of Evil-mode with a
single variable, and keep it untangled from all other packages/modes. I don't
know why I would ever want to disable Evil-mode, but I can if I want, I guess.

*** Related variables

#+BEGIN_SRC emacs-lisp
(setq my/evil-active t)
(setq my/evil-other-mode-funs ())
#+END_SRC

*** Built-in modes

Configure various modes that have little to configure and are built-in to Emacs.
Otherwise they add unnecessary clutter.

#+BEGIN_SRC emacs-lisp
    (defun setup-evil-builtins ()
      ;; Special
      (evil-make-overriding-map special-mode-map 'normal)

      ;; Compilation
      (evil-set-initial-state 'compilation-mode 'normal)

      ;; Occur
      (evil-make-overriding-map occur-mode-map 'normal)
      (evil-set-initial-state 'occur-mode 'normal)

      ;; Help
      (general-evil-define-key 'normal 'help-mode-map
        "q" 'quit-window
        "<" 'help-go-back
        ">" 'help-go-forward)

      ;; Bookmark
      (with-eval-after-load "bookmark"
        (evil-set-initial-state 'bookmark-bmenu-mode 'normal)
        (evil-make-overriding-map bookmark-bmenu-mode-map 'normal)
        (general-evil-define-key 'normal 'bookmark-bmenu-mode-map
          "RET" 'bookmark-bmenu-this-window
          "j" 'evil-next-line
          "k" 'evil-previous-line))

      ;; Shells (all three of them)
      (defun my/evil-shell-insert ()
        "Go to the very end of the buffer and enter insert state."
        (interactive)
        (evil-goto-line)
        (evil-append-line 0))
      (general-evil-define-key 'normal
          '(shell-mode-map eshell-mode-map term-mode-map)
        "I" 'my/evil-shell-insert
        "A" 'my/evil-shell-insert))
    (add-to-list 'my/evil-other-mode-funs 'setup-evil-builtins)
#+END_SRC

*** Evil Org

#+BEGIN_SRC emacs-lisp
  (defun setup-evil-org-mode ()
    (defhydra hydra-org-nav (:color red :hint nil)
      "
   ^Nav^   ^^^^| ^View^           ^^| ^Search^   | ^Exit Hydra
  -^---^---^^^^+-^----^-----------^^+-^------^---+-^-----------
   ^ ^ _k_ ^ ^ | _o_pen (_a_ppear), | _g_oto     | _b_ack_._
   _h_ ^+^ _l_ | hi_d_e,  _c_ycle,  | _s_wiper   | _q_uit_._
   ^ ^ _j_ ^ ^ | ^globally^ _C_ycle | ^ ^        | _w_oops!
  "
      ("j" worf-down)
      ("k" worf-up)
      ("h" worf-left)
      ("l" worf-right)
      ("a" my/show-header)
      ("o" my/show-header)
      ("d" hide-subtree)
      ("c" org-cycle)
      ("C" org-shifttab)
      ("g" org-goto :exit t)
      ("s" swiper)
      ("q" nil) ("b" nil)
      ("w" nil) ("." nil))

    (defun my/show-header ()
      (interactive)
      (show-children)
      (show-entry))

    (defhydra hydra-org-template (:color blue :hint nil)
      "
  _c_enter  _q_uote     _e_macs-lisp    _L_aTeX:
  _l_atex   _E_xample   _p_erl          _i_ndex:
  _a_scii   _v_erse     _P_erl tangled  _I_NCLUDE:
  _s_rc     ^ ^         plant_u_ml      _H_TML:
  _h_tml    ^ ^         ^ ^             _A_SCII:
  "
      ("s" (hot-expand "<s"))
      ("E" (hot-expand "<e"))
      ("q" (hot-expand "<q"))
      ("v" (hot-expand "<v"))
      ("c" (hot-expand "<c"))
      ("l" (hot-expand "<l"))
      ("h" (hot-expand "<h"))
      ("a" (hot-expand "<a"))
      ("L" (hot-expand "<L"))
      ("i" (hot-expand "<i"))
      ("e" (hot-expand "<s" "emacs-lisp"))
      ("p" (hot-expand "<s" "perl"))
      ("u" (hot-expand "<s" "plantuml :file CHANGE.png"))
      ("P" (progn
             (insert "#+HEADERS: :results output :exports "
             (insert "both :shebang \"#!/usr/bin/env perl\"\n")
             (hot-expand "<s" "perl"))))
      ("I" (hot-expand "<I"))
      ("H" (hot-expand "<H"))
      ("A" (hot-expand "<A"))
      ("<" self-insert-command "ins")
      ("o" nil "quit"))

      (defun hot-expand (str &optional mod)
        "Expand org template."
        (insert str)
        (org-try-structure-completion)
        (when mod (insert mod) (forward-line)))

      (defun call-hydra-org-template ()
        (interactive)
           (if (looking-back "^")
               (hydra-org-template/body)
               (self-insert-command 1)))

      (general-evil-define-key 'normal 'org-mode-map
      "RET" 'org-open-at-point
      ">" 'outline-demote
      "<" 'outline-promote
      "z g" 'org-goto
      "z ." 'hydra-org-nav/body
      "z j" 'hydra-org-nav/worf-down
      "z k" 'hydra-org-nav/worf-up
      "z h" 'hydra-org-nav/worf-left
      "z l" 'hydra-org-nav/worf-right)
    (general-evil-define-key 'insert 'org-mode-map
      "C-t" 'outline-demote
      "C-d" 'outline-promote
      "<" 'call-hydra-org-template)
    (general-evil-define-key '(normal visual insert) 'org-mode-map
      "M-h" 'org-metaleft
      "M-j" 'org-metadown
      "M-k" 'org-metaup
      "M-l" 'org-metaright
      "M-S-h" 'org-shiftmetaleft
      "M-S-j" 'org-shiftmetadown
      "M-S-k" 'org-shiftmetaup
      "M-S-l" 'org-shiftmetaright
      "C-S-h" 'org-shiftcontrolleft
      "C-S-j" 'org-shiftcontroldown
      "C-S-k" 'org-shiftcontrolup
      "C-S-l" 'org-shiftcontrolright)

    ;; Reveal cursor when going to marks
    (defun my/reveal-cursor (&rest _)
      (worf--ensure-visible))
    (advice-add 'evil-goto-mark :after #'my/reveal-cursor)

    (defun my/fix-org-evil-paragraphs ()
      "Make Evil mode's paragraph motions work correctly in Org mode."
      (setq paragraph-start "\\|[     ]*$"
            paragraph-separate "[       ]*$"))

    (add-hook 'org-mode-hook #'my/fix-org-evil-paragraphs))
  (add-to-list 'my/evil-other-mode-funs 'setup-evil-org-mode)
#+END_SRC

*** Evil Ibuffer

#+BEGIN_SRC emacs-lisp
  (defun setup-evil-ibuffer-mode ()
    (with-eval-after-load "ibuffer"
      (progn
        (evil-set-initial-state 'ibuffer-mode 'normal)
        (evil-make-overriding-map ibuffer-mode-map 'normal)
        (defhydra hydra-ibuffer-main (:color pink :hint nil)
          "
   ^Navigation^ | ^Mark^        | ^Actions^        | ^View^
  -^----------^-+-^----^--------+-^-------^--------+-^----^-------
    _k_:    ʌ   | _m_: mark     | _D_: delete      | _g_: refresh
   _RET_: visit | _u_: unmark   | _S_: save        | _s_: sort
    _j_:    v   | _*_: specific | _a_: all actions | _/_: filter
  -^----------^-+-^----^--------+-^-------^--------+-^----^-------
  "
          ("j" ibuffer-forward-line)
          ("RET" ibuffer-do-view :color blue)
          ("k" ibuffer-backward-line)

          ("m" ibuffer-mark-forward)
          ("u" ibuffer-unmark-forward)
          ("*" hydra-ibuffer-mark/body :color blue)

          ("D" ibuffer-do-delete)
          ("S" ibuffer-do-save)
          ("a" hydra-ibuffer-action/body :color blue)

          ("g" ibuffer-update)
          ("s" hydra-ibuffer-sort/body :color blue)
          ("/" hydra-ibuffer-filter/body :color blue)

          ("o" ibuffer-visit-buffer-other-window "other window" :color blue)
          ("q" ibuffer-quit "quit ibuffer" :color blue)
          ("." nil "toggle hydra" :color blue))

        (defhydra hydra-ibuffer-mark (:color teal :columns 5
                                      :after-exit (hydra-ibuffer-main/body))
          "Mark"
          ("*" ibuffer-unmark-all "unmark all")
          ("M" ibuffer-mark-by-mode "mode")
          ("m" ibuffer-mark-modified-buffers "modified")
          ("u" ibuffer-mark-unsaved-buffers "unsaved")
          ("s" ibuffer-mark-special-buffers "special")
          ("r" ibuffer-mark-read-only-buffers "read-only")
          ("/" ibuffer-mark-dired-buffers "dired")
          ("e" ibuffer-mark-dissociated-buffers "dissociated")
          ("h" ibuffer-mark-help-buffers "help")
          ("z" ibuffer-mark-compressed-file-buffers "compressed")
          ("b" hydra-ibuffer-main/body "back" :color blue))

        (defhydra hydra-ibuffer-action (:color teal :columns 4
                                        :after-exit
                                        (if (eq major-mode 'ibuffer-mode)
                                            (hydra-ibuffer-main/body)))
          "Action"
          ("A" ibuffer-do-view "view")
          ("E" ibuffer-do-eval "eval")
          ("F" ibuffer-do-shell-command-file "shell-command-file")
          ("I" ibuffer-do-query-replace-regexp "query-replace-regexp")
          ("H" ibuffer-do-view-other-frame "view-other-frame")
          ("N" ibuffer-do-shell-command-pipe-replace "shell-cmd-pipe-replace")
          ("M" ibuffer-do-toggle-modified "toggle-modified")
          ("O" ibuffer-do-occur "occur")
          ("P" ibuffer-do-print "print")
          ("Q" ibuffer-do-query-replace "query-replace")
          ("R" ibuffer-do-rename-uniquely "rename-uniquely")
          ("T" ibuffer-do-toggle-read-only "toggle-read-only")
          ("U" ibuffer-do-replace-regexp "replace-regexp")
          ("V" ibuffer-do-revert "revert")
          ("W" ibuffer-do-view-and-eval "view-and-eval")
          ("X" ibuffer-do-shell-command-pipe "shell-command-pipe")
          ("b" nil "back"))

        (defhydra hydra-ibuffer-sort (:color amaranth :columns 3)
          "Sort"
          ("i" ibuffer-invert-sorting "invert")
          ("a" ibuffer-do-sort-by-alphabetic "alphabetic")
          ("v" ibuffer-do-sort-by-recency "recently used")
          ("s" ibuffer-do-sort-by-size "size")
          ("f" ibuffer-do-sort-by-filename/process "filename")
          ("m" ibuffer-do-sort-by-major-mode "mode")
          ("b" hydra-ibuffer-main/body "back" :color blue))

        (defhydra hydra-ibuffer-filter (:color amaranth :columns 4)
          "Filter"
          ("m" ibuffer-filter-by-used-mode "mode")
          ("M" ibuffer-filter-by-derived-mode "derived mode")
          ("n" ibuffer-filter-by-name "name")
          ("c" ibuffer-filter-by-content "content")
          ("e" ibuffer-filter-by-predicate "predicate")
          ("f" ibuffer-filter-by-filename "filename")
          (">" ibuffer-filter-by-size-gt "size")
          ("<" ibuffer-filter-by-size-lt "size")
          ("/" ibuffer-filter-disable "disable")
          ("b" hydra-ibuffer-main/body "back" :color blue))

        (general-evil-define-key 'normal 'ibuffer-mode-map "." nil)
        (add-hook 'ibuffer-hook #'hydra-ibuffer-main/body)
        )))
  (add-to-list 'my/evil-other-mode-funs 'setup-evil-ibuffer-mode)
#+END_SRC

*** Evil Dired

Directory climbing inspired by [[https://github.com/tpope/vim-vinegar][tpope's vinegar]].

#+BEGIN_SRC emacs-lisp
  (defun setup-evil-dired-mode ()
    (with-eval-after-load "dired"
      (progn
        (defun my/up-dir ()
          (interactive)
          (find-alternate-file ".."))
        (evil-make-overriding-map dired-mode-map 'normal)
        (general-define-key :states 'normal "-" (kbd "C-x d RET"))
        (general-evil-define-key 'normal 'dired-mode-map
          "-" 'my/up-dir
          "RET" 'dired-find-alternate-file
          "i" 'ido-find-file
          "j" 'dired-next-line
          "k" 'dired-previous-line))))
  (add-to-list 'my/evil-other-mode-funs 'setup-evil-dired-mode)
#+END_SRC

*** Evil Magit

#+BEGIN_SRC emacs-lisp
  (defun setup-evil-magit-mode ()
    (with-eval-after-load "magit"
      (progn
        (evil-set-initial-state 'magit-status-mode 'normal)
        (evil-set-initial-state 'magit-log-mode 'normal)
        (evil-set-initial-state 'magit-diff-mode 'normal)
        (evil-make-overriding-map magit-mode-map 'normal)
        (general-evil-define-key 'normal 'magit-mode-map
          "j" [down]
          "k" [up]
          "c" 'magit-commit-popup)
        (general-evil-define-key 'normal 'magit-diff-mode-map
          "C-j" 'evil-scroll-down)))

        ;; Leader shortcuts
        (general-define-key
         :states '(normal motion emacs)
         :prefix "SPC"
         "gs" 'magit-status
         "gd" 'magit-diff
         "gc" 'magit-commit
         "gl" 'magit-log
         "gp" 'magit-push
         "gw" 'magit-stage-file   ;; "write"
         "gr" 'magit-unstage-file ;; "remove"
         "gg" 'vc-git-grep))
  (add-to-list 'my/evil-other-mode-funs 'setup-evil-magit-mode)
#+END_SRC

*** Evil Projectile

#+BEGIN_SRC emacs-lisp
  (defun setup-evil-projectile-mode ()
    ;; Leader shortcuts
    (general-define-key
     :states '(normal motion emacs)
     :prefix "SPC"
     "p"  (general-simulate-keys "C-c p")))
  (add-to-list 'my/evil-other-mode-funs 'setup-evil-projectile-mode)
#+END_SRC

*** Evil Ivy+Swiper

#+BEGIN_SRC emacs-lisp
  (defun setup-evil-ivyswiper-mode ()

    ;; Vimish bindings
    (general-define-key
     :keymaps 'ivy-minibuffer-map
     "C-j" 'ivy-next-line
     "C-k" 'ivy-previous-line
     "C-n" 'ivy-next-history-element
     "C-p" 'ivy-previous-history-element
     "C-w" 'ivy-backward-kill-word)
    (general-define-key
     :keymaps 'swiper-map
     "C-r" 'swiper-query-replace)

    ;; Leader shortcuts
    (general-define-key
     :states '(normal motion emacs)
     :prefix "SPC"
     "SPC"  'counsel-M-x
     "b" 'ivy-switch-buffer
     "f" 'counsel-find-file
     ))
  (add-to-list 'my/evil-other-mode-funs 'setup-evil-ivyswiper-mode)
#+END_SRC

*** Evil Info

#+BEGIN_SRC emacs-lisp
  (defun setup-evil-info-mode ()
    (defhydra hydra-info (:color red
                                 :hint nil)
      "
  Info-mode:

    ^^_]_ forward  (next logical node)       ^^_l_ast (←)        _u_p (↑)                             _f_ollow reference       _T_OC
    ^^_[_ backward (prev logical node)       ^^_r_eturn (→)      _m_enu (↓) (C-u for new window)      _i_ndex                  _d_irectory
    ^^_n_ext (same level only)               ^^_H_istory         _g_oto (C-u for new window)          _,_ next index item      _c_opy node name
    ^^_p_rev (same level only)               _<_/_t_op           _b_eginning of buffer                virtual _I_ndex          _C_lone buffer
    regex _s_earch (_S_ case sensitive)      ^^_>_ final         _e_nd of buffer                      ^^                       _a_propos

    _1_ .. _9_ Pick first .. ninth item in the node's menu.
  "
      ("]"   Info-forward-node)
      ("["   Info-backward-node)
      ("n"   Info-next)
      ("p"   Info-prev)
      ("s"   Info-search)
      ("S"   Info-search-case-sensitively)

      ("l"   Info-history-back)
      ("r"   Info-history-forward)
      ("H"   Info-history)
      ("t"   Info-top-node)
      ("<"   Info-top-node)
      (">"   Info-final-node)

      ("u"   Info-up)
      ("^"   Info-up)
      ("m"   Info-menu)
      ("g"   Info-goto-node)
      ("b"   beginning-of-buffer)
      ("e"   end-of-buffer)

      ("f"   Info-follow-reference)
      ("i"   Info-index)
      (","   Info-index-next)
      ("I"   Info-virtual-index)

      ("T"   Info-toc)
      ("d"   Info-directory)
      ("c"   Info-copy-current-node-name)
      ("C"   clone-buffer)
      ("a"   info-apropos)

      ("1"   Info-nth-menu-item)
      ("2"   Info-nth-menu-item)
      ("3"   Info-nth-menu-item)
      ("4"   Info-nth-menu-item)
      ("5"   Info-nth-menu-item)
      ("6"   Info-nth-menu-item)
      ("7"   Info-nth-menu-item)
      ("8"   Info-nth-menu-item)
      ("9"   Info-nth-menu-item)

      ("?"   Info-summary "Info summary")
      ("h"   Info-help "Info help")
      ("q"   Info-exit "Info exit" :color blue)
      ("." nil "toggle hydra" :color blue))
    (general-evil-define-key 'normal 'Info-mode-map
      "." 'hydra-info/body
      "TAB" 'Info-next-reference
      "S-TAB" 'Info-prev-reference
      "RET" 'Info-follow-nearest-node
      "C-p" 'Info-history-back
      "C-n" 'Info-history-forward
      "q" 'Info-exit))
  (add-to-list 'my/evil-other-mode-funs 'setup-evil-info-mode)
#+END_SRC

*** Evil Shell(s)

#+BEGIN_SRC emacs-lisp
  (defun setup-evil-shell-mode ())
  (add-to-list 'my/evil-other-mode-funs 'setup-evil-shell-mode)
#+END_SRC

** Post-activation setup function

Runs after Evil-mode is activated, and contains mostly all of my configuration
for Evil.

*** START function

#+BEGIN_SRC emacs-lisp
(defun setup-evil-settings ()
#+END_SRC

*** General settings

**** Normal state == Motion state

Basically avoid Motion state and use Normal state instead. I don't need Motion
state, so it adds unnecessary complexity.

#+BEGIN_SRC emacs-lisp
(setq evil-normal-state-modes (append evil-motion-state-modes evil-normal-state-modes))
(setq evil-motion-state-modes nil)
#+END_SRC

**** Cursor color/shape to indicate modes/states

Match GVim's cursor shapes.

#+BEGIN_SRC emacs-lisp
  (setq evil-normal-state-cursor   '("dodger blue" box)
        evil-insert-state-cursor   '("dodger blue" bar)
        evil-replace-state-cursor  '("dodger blue" hbar)
        evil-operator-state-cursor '("dodger blue" (hbar . 7))
        evil-visual-state-cursor   '("orange" box)
        evil-motion-state-cursor   '("deep pink" box)
        evil-emacs-state-cursor    '("red2" box))
#+END_SRC

**** Auto-switch to help window like Vim

#+BEGIN_SRC emacs-lisp
(setq help-window-select t)
#+END_SRC

**** Dehighlight search when finished searching

#+BEGIN_SRC emacs-lisp
  (defun my/evil-search-nohl-on-move ()
    "Dehighlight Evil ex search when any keys other than n or N are pressed."
    (interactive)
    (if (not (or (equal (this-command-keys) "n")
                 (equal (this-command-keys) "N")))
        (progn (evil-ex-nohighlight)
               (remove-hook 'pre-command-hook
                            'my/evil-search-nohl-on-move))))

  (defun my/add-hook-evil-search (&rest _)
    (add-hook 'pre-command-hook 'my/evil-search-nohl-on-move))

  (advice-add 'evil-ex-start-search :after #'my/add-hook-evil-search)
  (advice-add 'evil-ex-search :after #'my/add-hook-evil-search)
#+END_SRC

**** Center view advice

Center the view when certain functions are called.

#+BEGIN_SRC emacs-lisp
  (setq my/funs-to-center '(evil-ex-search
                            evil-ex-start-search
                            evil-goto-line
                            evil-goto-mark
                            evil-goto-mark-line))

  (defun my/scroll-to-center (&rest _)
    (evil-scroll-line-to-center nil))

  (dolist (fun my/funs-to-center)
    (advice-add fun :after #'my/scroll-to-center))
#+END_SRC

**** clear trailing whitespace ex command

#+BEGIN_SRC emacs-lisp
(evil-ex-define-cmd "ctw" 'delete-trailing-whitespace)
#+END_SRC

**** Re-enable evil-make-overriding/intercept-map

They were disabled before so that I can have complete control over key bindings.
They're being enabled again so that I can make use of them.

#+BEGIN_SRC emacs-lisp
(advice-remove 'evil-make-overriding-map #'my-kill-overriding-maps)
(advice-remove 'evil-make-intercept-map #'my-kill-intercept-maps)
#+END_SRC

*** Global bindings

These are mostly remaps and convenience shortcuts for Evil mode.

**** Make defining bindings more vim-like with [[*Enhanced%20key%20binding][general.el]]

=nmap= looks so much nicer than =general-define-key :states 'normal=.

#+BEGIN_SRC emacs-lisp
  (general-evil-setup t 'current-global-map)
#+END_SRC

**** In case M-x is weirdly undefined

#+BEGIN_SRC emacs-lisp
  (nmap "M-x" 'execute-extended-command)
#+END_SRC

**** Back to last buffer

#+BEGIN_SRC emacs-lisp
  (nmap "DEL" 'evil-switch-to-windows-last-buffer)
#+END_SRC

**** U instead of C-r for redo

#+BEGIN_SRC emacs-lisp
  (nmap "U" 'redo)
#+END_SRC

**** Q to replay q register

#+BEGIN_SRC emacs-lisp
  (nmap "Q" "@q")
#+END_SRC

**** [S]plit Line (sister to [J]oin Line)

#+BEGIN_SRC emacs-lisp
  (defun my/split-line ()
  (interactive)
  (newline-and-indent) (forward-line -1) (move-end-of-line 1))
  (nmap "S" 'my/split-line )
#+END_SRC

**** =_= and =|= to split windows

also focus on the new split window like Vim

#+BEGIN_SRC emacs-lisp
  (defun evil-window-split ()
  "Split current window vertically and focus on the new window."
  (interactive)
  (split-window-vertically)
  (other-window 1))
  (defun evil-window-vsplit ()
  "Split current window horizontally and focus on the new window."
  (interactive)
  (split-window-horizontally)
  (other-window 1))
  (nmap "|" 'evil-window-vsplit
        "_" 'evil-window-split)
#+END_SRC

**** Jump list (previous, next)

#+BEGIN_SRC emacs-lisp
  (nmap "C-p" 'evil-jump-backward
        "C-n" 'evil-jump-forward)
#+END_SRC

**** select last pasted/changed text

#+BEGIN_SRC emacs-lisp
  (nmap "gp" (general-simulate-keys "` [ v ` ]"))
#+END_SRC

**** Convenient scrolling

Aside from being more comfortable, this keeps standard =C-u=
(universal-argument) available.

#+BEGIN_SRC emacs-lisp
  (nmap "C-j" 'evil-scroll-down
        "C-k" 'evil-scroll-up)
#+END_SRC

**** format last pasted/changed text

#+BEGIN_SRC emacs-lisp
  (nmap "g=" (general-simulate-keys "` [ v ` ] ="))
#+END_SRC

**** evil-unimpaired

Inspired by [[https://github.com/tpope/vim-unimpaired][unimpaired]]:

#+BEGIN_SRC emacs-lisp
  (defun my/evil-blank-above (count)
    "Add [count] blank lines above the point."
    (interactive "p")
    (setq col (current-column))
    (while (> count 0)
      (evil-insert-newline-above)
      (forward-line 1)
      (add-hook 'post-command-hook #'evil-maybe-remove-spaces)
      (setq count (- count 1)))
    (move-to-column col))
  (defun my/evil-blank-below (count)
    "Add [count] blank lines below the point."
    (interactive "p")
    (setq col (current-column))
    (while (> count 0)
      (evil-insert-newline-below)
      (forward-line -1)
      (add-hook 'post-command-hook #'evil-maybe-remove-spaces)
      (setq count (- count 1)))
    (move-to-column col))
  (nmap "[ SPC" 'my/evil-blank-above
        "] SPC" 'my/evil-blank-below
        "[ b" 'previous-buffer
        "] b" 'next-buffer)
#+END_SRC

**** C-g to see total line numbers like Vim

#+BEGIN_SRC emacs-lisp
  (nmap "C-g" 'count-words)
#+END_SRC

**** Insert movement

#+BEGIN_SRC emacs-lisp
  (imap "C-a" 'move-beginning-of-line
        "C-e" 'move-end-of-line)
#+END_SRC

**** Always cancel/escape to normal state

#+BEGIN_SRC emacs-lisp
(general-define-key :states '(visual insert replace motion)
                    "C-g" 'evil-normal-state
                    "C-[" 'evil-normal-state)
#+END_SRC

**** "entire" text object (ae and ie)

For operating on the entire file.

#+BEGIN_SRC emacs-lisp
(load-file "~/.emacs.d/elisp/evil-textobj-entire.el")
#+END_SRC

*** Leader bindings

The "leader" key is a concept from Vim, and it's just a global prefix key like
=C-x= or =C-c=, but for personal use. I use the spacebar as my primary leader
key, and [[https://github.com/noctuid/general.el][general.el]] to make it easy.

Leader bindings may be defined for other packages under [[*Compatibility%20with%20other%20modes][their own configuration]].

#+BEGIN_SRC emacs-lisp
  (defun my/open-init-el ()
    (interactive)
    (find-file "~/.emacs.d/config.org"))

  (defhydra hydra-toggle-option (:color blue
                                 :columns 1)
    "Toggle"
    ("t" toggle-truncate-lines "truncate lines")
    ("n" linum-mode "linum-mode")
    ("w" toggle-word-wrap "word wrap")
    ("W" whitespace-mode "whitespace-mode")
    ;; TODO: look into cross-platform spell checker
    ("s" flyspell-mode "spell check"))

  (general-define-key
   :states '(normal motion emacs)
   :prefix "SPC"

   ;;  Avoiding CTRL
   "w" (general-simulate-keys "C-w")
   "x" (general-simulate-keys "C-x")
   "c" (general-simulate-keys "C-c")
   "h" (general-simulate-keys "C-h")

   ;; The Rest
   "TAB" 'other-window
   "s"  'evil-write
   "e"  'eval-last-sexp
   "q"  'quit-window
   "f"  'ido-find-file
   "b"  'ido-switch-buffer
   "B"  'ibuffer
   "o"  'hydra-toggle-option/body
   "i"  'my/open-init-el)
#+END_SRC

*** Run compatibility functions

Run a list of functions to make other modes "more evil." See [[Compatibility with
other modes]].

#+BEGIN_SRC emacs-lisp
(dolist (fun my/evil-other-mode-funs) (funcall fun))
#+END_SRC

*** END function

#+BEGIN_SRC emacs-lisp
  )
#+END_SRC

** Install Evil mode

Just to be explicit.

#+BEGIN_SRC emacs-lisp
  (use-package evil)
#+END_SRC

** Basic options

#+BEGIN_SRC emacs-lisp
  (use-package evil
    :init
    ;; Pre-defined Evil options
    (setq evil-ex-substitute-global t
          evil-want-fine-undo "No"
          evil-want-Y-yank-to-eol t
          evil-overriding-maps nil
          evil-search-module 'evil-search)

    ;; Persistent undo history (save info to file)
    (setq undo-tree-auto-save-history t
          undo-tree-history-directory-alist `((".*" . "~/.emacs.d/tmp"))))
#+END_SRC

** Disable evil-make-overriding/intercept-map at start-up.

Otherwise, Evil will mess with other mode's mappings. I want to mess with them
myself, instead.

#+BEGIN_SRC emacs-lisp
  (use-package evil
    :init
    (advice-add 'evil-make-intercept-map
                :override (defun my-kill-intercept-maps (&rest _)))
    (advice-add 'evil-make-overriding-map
                :override (defun my-kill-overriding-maps (&rest _))))
#+END_SRC

** Hook to configure Evil after activation

#+BEGIN_SRC emacs-lisp
  (use-package evil
    :config
    (add-hook 'evil-mode-hook 'setup-evil-settings))
#+END_SRC

** Evil-specific packages

These packages are installed/configured *after* Evil is loaded, but *before*
it's activated. In my experience, this works well with Evil-related packages.

*** START :config

#+BEGIN_SRC emacs-lisp
  (use-package evil
      :config
#+END_SRC

*** [[https://github.com/timcharper/evil-surround][evil-surround]]

Manipulate surroundings

#+BEGIN_SRC emacs-lisp
(use-package evil-surround
  :config
  (global-evil-surround-mode))
#+END_SRC

*** [[https://github.com/Dewdrops/evil-exchange][evil-exchange]]

Exchange operator

#+BEGIN_SRC emacs-lisp
  (use-package evil-exchange
      :config
    ;; "[g]o e[x]change"
    ;; gX is cancel
    (evil-exchange-install))
#+END_SRC

*** [[https://github.com/redguardtoo/evil-nerd-commenter][evil-nerd-commenter]]

Comment operator

#+BEGIN_SRC emacs-lisp
(use-package evil-nerd-commenter
  :config
  (general-define-key :states '(normal visual) "gc"
  'evilnc-comment-operator))
#+END_SRC

*** [[https://github.com/bling/evil-visualstar][evil-visualstar]]

Make a visual selection, and search it. Convenient and intuitive.

#+BEGIN_SRC emacs-lisp
(use-package evil-visualstar
  :config
  (global-evil-visualstar-mode))
#+END_SRC

*** [[https://github.com/CodeFalling/nlinum-relative][nlinum-relative]]

Relative line numbers

#+BEGIN_SRC emacs-lisp
  (use-package nlinum-relative
    :init
    (setq nlinum-relative-current-symbol "->")
    :config
    (add-hook 'prog-mode-hook 'nlinum-relative-mode))
#+END_SRC

*** [[https://github.com/noctuid/emacs-sentence-navigation][emacs-sentence-navigation]]

Improved sentence logic and navigation.

#+BEGIN_SRC emacs-lisp
  (use-package sentence-navigation
    :config
    (define-key evil-normal-state-map ")" 'sentence-nav-evil-forward)
    (define-key evil-normal-state-map "(" 'sentence-nav-evil-backward)
    (define-key evil-normal-state-map "g)" 'sentence-nav-evil-forward-end)
    (define-key evil-normal-state-map "g(" 'sentence-nav-evil-backward-end)
    (define-key evil-outer-text-objects-map "s" 'sentence-nav-evil-outer-sentence)
    (define-key evil-inner-text-objects-map "s" 'sentence-nav-evil-inner-sentence)
    :defer t)
#+END_SRC

*** [[https://github.com/noctuid/lispyville][lispyville]]

Better lisp editing for Evil. (With some help from [[https://github.com/abo-abo/lispy][lispy]])

#+BEGIN_SRC emacs-lisp
  (use-package lispy
    :diminish lispyville-mode
    :config
    (with-eval-after-load 'lispyville
      (lispyville-set-key-theme '(slurp/barf-cp)))
    (load-file "~/.emacs.d/elisp/lispyville.el")
    (add-hook 'lisp-mode-hook #'lispyville-mode)
    (add-hook 'emacs-lisp-mode-hook #'lispyville-mode))
#+END_SRC

*** END :config (also activate Evil)

#+BEGIN_SRC emacs-lisp
  (evil-mode 1))
#+END_SRC

