#+TITLE: An Emacs Config
#+AUTHOR: Austin Smith
#+EMAIL: AssailantLF@gmail.com

* Preamble

This is my Emacs config, which is (pretty much) in a single file thanks to
[[http://orgmode.org/worg/org-contrib/babel/intro.html][org-babel]].

Although GitHub does render =.org= files nicely, I recommend viewing it within
Emacs org-mode, where everything is collapsible and all the links work.

GitHub doesn't translate links to headings correctly, so [[*Preamble][this link to the
Preamble]], for example, will only work in org-mode. Regular web-url links will
work either way.

* Package related

Setup general package related settings.

** package.el

Initialize package.el, the built-in package manager.

#+BEGIN_SRC emacs-lisp
  (package-initialize)
#+END_SRC

These are the package repositories I use:

#+BEGIN_SRC emacs-lisp
  (setq package-archives '(("gnu" . "http://elpa.gnu.org/packages/")
                           ("melpa" . "http://melpa.org/packages/")
                           ("melpa-stable" . "http://stable.melpa.org/packages/")))
#+END_SRC

** use-package

Install/activate [[https://github.com/jwiegley/use-package][use-package]], basically a wrapper for =package.el=.

- makes installing and configuring other packages nicer and easier
- helps with autoloading packages to greatly reduce initial startup time

#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
  (require 'use-package)
  (setq use-package-always-ensure t)
#+END_SRC

* Appearance related

Setup appearance early so that if something goes wrong with the init, Emacs is
still lookin' good. These settings (mostly) shouldn't affect any functionality.

** Maximize Emacs on startup

This snippet works in *nix and all (relevant) versions of Windows.

#+BEGIN_SRC emacs-lisp
  (defun w32-maximize-frame ()
    "Maximize the current frame (windows only)"
    (interactive)
    (w32-send-sys-command 61488))
  (if (eq system-type 'windows-nt)
      (progn
        (add-hook 'window-setup-hook #'w32-maximize-frame t))
    (set-frame-parameter nil 'fullscreen 'maximized))
#+END_SRC

** Minimal GUI

Remove unnecessary GUI elements: menu-bar, tool-bar, and scroll-bar.

#+BEGIN_SRC emacs-lisp
  (if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
  (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
#+END_SRC

** No splash screen

Interesting trivia: Emacs originally opened to the scratch buffer by default.

#+BEGIN_SRC emacs-lisp
  (setq inhibit-splash-screen t)
#+END_SRC

** Initial scratch buffer message

NO DISTRACTIONS.

#+BEGIN_SRC emacs-lisp
  (setq initial-scratch-message "")
#+END_SRC

** Default Font

#+BEGIN_SRC emacs-lisp
  ;; when "font" is available
  (if (eq system-type 'windows-nt)
      (when (member "Consolas" (font-family-list))
        (add-to-list 'default-frame-alist '(font . "Consolas-10" ))
        (set-face-attribute 'default t :font "Consolas-10"))
      (when (member "DejaVu Sans Mono" (font-family-list))
        (add-to-list 'default-frame-alist '(font . "DejaVu Sans Mono-9" ))
        (set-face-attribute 'default t :font "DejaVu Sans Mono-9")))
#+END_SRC

** STOP THE BEEPING AND FLASHING

#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function 'ignore)
#+END_SRC

** Theme

*** Eclipse theme

A nice, light theme.

#+BEGIN_SRC emacs-lisp
  (use-package eclipse-theme
      :load-path "~/.emacs.d/elisp"
      :config
      (load-theme 'eclipse t))
#+END_SRC

*** Monokai

A nice, dark theme.

#+BEGIN_SRC emacs-lisp
  ;; (use-package monokai-theme
  ;;      :init
  ;;    (setq monokai-use-variable-pitch nil
  ;;          monokai-height-minus-1 1.0
  ;;          monokai-height-plus-1 1.0
  ;;          monokai-height-plus-2 1.0
  ;;          monokai-height-plus-3 1.0
  ;;          monokai-height-plus-4 1.0)
  ;;    :config
  ;;    (load-theme 'monokai t)
  ;;    )
#+END_SRC

** SmartModeLine

Mostly makes the mode line easier to read.

#+BEGIN_SRC emacs-lisp
  (use-package smart-mode-line
      :config
    (setq sml/no-confirm-load-theme t)
    (setq sml/theme 'respectful)
    ;; (setq sml/theme 'dark)
    (sml/setup))
#+END_SRC

** RainbowDelimiters

Highlight matching delimiters with unique colors. It's pretty indispensable for
lisp with all its mad parenthesis.

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
      :commands (rainbow-delimiters-mode)
      :init
      (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+END_SRC

** Highlight matching parenthesis

Specifically the ones under the cursor.

#+BEGIN_SRC emacs-lisp
  (custom-set-variables '(show-paren-delay 0.0))
  (show-paren-mode t)
#+END_SRC

** Highlight trailing white space

(Only for programming languages)

Trailing white space is something that you hate once you know it's there. Or at
least it is for me.

#+BEGIN_SRC emacs-lisp
  (defun my/buf-show-trailing-whitespace ()
    (interactive)
    (setq show-trailing-whitespace t))
  (add-hook 'prog-mode-hook #'my/buf-show-trailing-whitespace)
  (custom-set-faces '(trailing-whitespace ((t (:background "dim gray")))))
#+END_SRC

** Prettify symbols

Convert certain words into symbols. Prime example: =lambda= becomes =Î»=.

#+BEGIN_SRC emacs-lisp
  (global-prettify-symbols-mode)
#+END_SRC

** Indicate lines after EOF

Use tildes like Vim :>

#+BEGIN_SRC emacs-lisp
  (define-fringe-bitmap 'tilde [0 0 0 113 219 142 0 0] nil nil 'center)
  (setcdr (assq 'empty-line fringe-indicator-alist) 'tilde)
  (set-fringe-bitmap-face 'tilde 'font-lock-comment-face)
  (setq-default indicate-empty-lines t)
#+END_SRC

** Show column number in modeline

#+BEGIN_SRC emacs-lisp
  (column-number-mode t)
#+END_SRC

** Diminish

Use diminish to clean up the mode line. The mode line is cluttered as heck
without this. I use the =:diminish= key word for =use-package= when I can.

#+BEGIN_SRC emacs-lisp
  (use-package diminish
      :config
    (eval-after-load "hideshow" '(diminish 'hs-minor-mode))
    (eval-after-load "undo-tree" '(diminish 'undo-tree-mode))
    (eval-after-load "simple" '(diminish 'overwrite-mode))
    (eval-after-load "autorevert" '(diminish 'auto-revert-mode)))
#+END_SRC

* General settings

These settings don't belong to any specific mode or package. Some packages are
exceptional for being very simple.

** Start server if it isn't started

Turn the first Emacs process into a server, which allows reuse of a that process
through the shell command =emacsclient=.

#+BEGIN_SRC emacs-lisp
  (require 'server)
  (if (not (server-running-p)) (server-start))
#+END_SRC

** Backup & auto-save files in one place

These files are useful if something goes wrong, but they're also annoying in how
they clutter directories. Put them in =~/.emacs.d/tmp= to remedy this.

#+BEGIN_SRC emacs-lisp
  (setq backup-directory-alist `((".*" . "~/.emacs.d/tmp"))
        auto-save-file-name-transforms `((".*" , "~/.emacs.d/tmp" t)))
#+END_SRC

** Scroll smoothly

#+BEGIN_SRC emacs-lisp
  (setq scroll-margin 0)
  (setq scroll-conservatively 10000)
  (setq scroll-preserve-screen-position t)
#+END_SRC

** Sentences end with a single period

#+BEGIN_SRC emacs-lisp
  (setq sentence-end-double-space nil)
#+END_SRC

** y/n instead of yes/no

#+BEGIN_SRC emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Wrap text at 80 characters

#+BEGIN_SRC emacs-lisp
  (setq-default fill-column 80)
#+END_SRC

** Indent with spaces by default

Tabs are weird and can have varying lengths, so I prefer spaces.

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
#+END_SRC

** Auto-detect indent settings

I prefer to follow a file's indenting style instead of enforcing my own, if
possible. =dtrt-indent= does this and works for most mainstream languages.

#+BEGIN_SRC emacs-lisp
  (use-package dtrt-indent)
#+END_SRC

** Auto-update changed files

If a file is changed outside of Emacs, automatically load those changes.

#+BEGIN_SRC emacs-lisp
  (global-auto-revert-mode t)
#+END_SRC

** Auto-executable scripts in *nix

When saving a file that starts with =#!=, make it executable.

#+BEGIN_SRC emacs-lisp
  (add-hook 'after-save-hook
            #'executable-make-buffer-file-executable-if-script-p)
#+END_SRC

** Enable HideShow in programming modes

Useful for getting an overview of the code. It works better in some
languages and layouts than others.

#+BEGIN_SRC emacs-lisp
  (defun my/enable-hideshow ()
    (interactive)
    (hs-minor-mode t))
  (add-hook 'prog-mode-hook #'my/enable-hideshow)
#+END_SRC

** Recent Files

Enable =recentf-mode= and remember a lot of files.

#+BEGIN_SRC emacs-lisp
  (recentf-mode 1)
  (setq recentf-max-saved-items 200)
#+END_SRC

** Better same-name buffer distinction

When two buffers are open with the same name, this makes it easier to tell them
apart.

#+BEGIN_SRC emacs-lisp
  (require 'uniquify)
  (setq uniquify-buffer-name-style 'forward)
#+END_SRC

** Remember last position for reopened files

#+BEGIN_SRC emacs-lisp
  (if (version< emacs-version "25.0")
      (progn (require 'saveplace)
             (setq-default save-place t))
    (save-place-mode 1))
#+END_SRC

** Disable garbage collection in minibuffer

See [[http://tiny.cc/7wd7ay][this article]] for more info.

#+BEGIN_SRC emacs-lisp
  (defun my/minibuffer-setup-hook ()
    (setq gc-cons-threshold most-positive-fixnum))
  (defun my/minibuffer-exit-hook ()
    (setq gc-cons-threshold 800000))
  (add-hook 'minibuffer-setup-hook #'my/minibuffer-setup-hook)
  (add-hook 'minibuffer-exit-hook #'my/minibuffer-exit-hook)
#+END_SRC

** UTF-8 encoding plz

I loves me some unicode.

#+BEGIN_SRC emacs-lisp
  (set-locale-environment "pl_PL.UTF-8")
  (set-language-environment 'utf-8)
  (setq locale-coding-system 'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (unless (eq system-type 'windows-nt)
    (progn
      (set-selection-coding-system 'utf-8)
      (set-keyboard-coding-system 'utf-8-mac)))
  (prefer-coding-system 'utf-8)
#+END_SRC

** Edit with root/admin privileges

Source: [[https://emacsredux.com/blog/2013/04/21/edit-files-as-root/][This article from the Emacs Redux blog.]]

#+BEGIN_SRC emacs-lisp
  (defun sudo-edit (&optional arg)
    "Edit currently visited file as root.

  With a prefix ARG prompt for a file to visit.
  Will also prompt for a file to visit if current
  buffer is not visiting a file."
    (interactive "P")
    (if (or arg (not buffer-file-name))
        (find-file (concat "/sudo:root@localhost:"
                           (ido-read-file-name "Find file(as root): ")))
        (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name))))
#+END_SRC

* Key binding related

These are global bindings, and packages that affect key binding in general.

** Enhanced key binding

[[https://github.com/noctuid/general.el][general.el]] is one of my favorite packages, and makes it much nicer and easier to
bind keys. Particularly useful for Evil mode and its various states.

#+BEGIN_SRC emacs-lisp
      (use-package general
          :load-path "~/.emacs.d/elisp/general.el"
          :ensure nil)
#+END_SRC

** The Mighty Hydra

I'm a big fan of [[https://github.com/abo-abo/hydra][Hydra]]. Search for =defhydra= in this file to check out all my
hydras.

What is a hydra? From the README:

#+BEGIN_QUOTE
This is a package for GNU Emacs that can be used to tie related commands into a
family of short bindings with a common prefix - a Hydra.
#+END_QUOTE

followed by a description for poets:

#+BEGIN_QUOTE
Once you summon the Hydra through the prefixed binding (the body + any one
head), all heads can be called in succession with only a short extension.

The Hydra is vanquished once Hercules, any binding that isn't the Hydra's head,
arrives. Note that Hercules, besides vanquishing the Hydra, will still serve his
original purpose, calling his proper command. This makes the Hydra very
seamless, it's like a minor mode that disables itself auto-magically.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
  (use-package hydra
      :config
    ;; Use a lighter red for my dark backgrounds
    (set-face-foreground 'hydra-face-red "#FF3232"))
#+END_SRC

** Show available key bindings

Use [[https://github.com/justbur/emacs-which-key][which-key]] or [[https://github.com/kai2nenobu/guide-key][guide-key]] to display key bindings. =which-key= is a
superior package, but isn't compatible with older versions of Emacs.

#+BEGIN_SRC emacs-lisp
  (if (version< emacs-version "24.4")
      (use-package guide-key
          :defer 2
          :init
          (setq guide-key/guide-key-sequence t
                guide-key/recursive-key-sequence-flag t
                guide-key/popup-window-position 'bottom
                guide-key/idle-delay 0.5)
          :config
          (guide-key-mode 1))
    (use-package which-key
        :defer 2
        :diminish ""
        :init
        (setq which-key-idle-delay 0.5
              which-key-side-window-max-height 0.50
              which-key-allow-evil-operators t
              which-key-show-operator-state-maps nil)
        :config
        (which-key-mode)
        ;; show top-level bindings, I don't need the Emacs tutorial
        (general-define-key "C-h t" 'which-key-show-top-level)))
#+END_SRC

** Resize text easier

Resize text like every other program does.

#+BEGIN_SRC emacs-lisp
  (defun text-scale-reset ()
    "Reset the text scale to 0."
    (interactive)
    (text-scale-set 0))
  (general-define-key
   "C-0" 'text-scale-reset
   "C-=" 'text-scale-increase
   "C--" 'text-scale-decrease)
#+END_SRC

** Kill current buffer

When using =C-x k=, I almost always want to kill the current buffer. So do that
by default.

#+BEGIN_SRC emacs-lisp
  (general-define-key
   "C-x k" 'kill-this-buffer)
#+END_SRC

* Language-specific

** C/C++

Coding style preferences:

#+BEGIN_SRC emacs-lisp
  (defun my-case-helper (sym-and-anchor)
    (let* ((new-offset '+) ; if there's nothing after the case colon, just indent by c-basic-offset
           (anchor (cdr sym-and-anchor))
           (anchor-line (line-number-at-pos anchor)))
      (save-excursion
        (goto-char anchor)
        (search-forward-regexp ":[[:space:]]*[^[:space:]{]" nil t)
        ;; did we find non-whitespace (and not just an open brace) after
        ;; the colon on the case line?
        (if (and (> (point) anchor)
                 (= anchor-line (line-number-at-pos)))
            (setq new-offset (- (point) anchor 1)))
        new-offset)))

  (c-add-style "my-style"
               '("linux"
                 (c-offsets-alist
                  (statement-case-intro . my-case-helper))))

  (setq c-basic-offset 4
        c-default-style
        (quote
         ((c-mode . "my-style")
          (c++-mode . "my-style")
          (java-mode . "java")
          (awk-mode . "awk")
          (other . "gnu"))))

  (c-set-offset 'case-label '+)
#+END_SRC

** lisp

Coding style preferences:

#+BEGIN_SRC emacs-lisp
  (setq lisp-indent-function 'common-lisp-indent-function)

  (put 'if 'common-lisp-indent-function 2)
  (put 'defface 'common-lisp-indent-function 1)
  (put 'define-minor-mode 'common-lisp-indent-function 1)
  (put 'define-derived-mode 'common-lisp-indent-function 3)
  (put 'cl-flet 'common-lisp-indent-function
       (get 'flet 'common-lisp-indent-function))
  (put 'cl-labels 'common-lisp-indent-function
       (get 'labels 'common-lisp-indent-function))
#+END_SRC

* Setup various packages & modes

** Restart Emacs

Useful because I edit my config frequently

#+BEGIN_SRC emacs-lisp
  (use-package restart-emacs
      :commands (restart-emacs)
      :bind ("C-x C-r" . restart-emacs))
#+END_SRC

** s.el

The long lost Emacs string manipulation library.

#+BEGIN_SRC emacs-lisp
  (use-package s
      :commands (s-suffix?))
#+END_SRC

** Multi-term

Minor improvements over standard =:term= or =:ansi-term=. Also makes managing
multiple terminals easier.

#+BEGIN_SRC emacs-lisp
  (use-package multi-term)
#+END_SRC

** Org-mode

*** Autoload

#+BEGIN_SRC emacs-lisp
  (use-package org
      :defer 4
      :commands (org-babel-load-file
                 org-babel-tangle-file)
      :mode ("\\.org\\'" . org-mode))
#+END_SRC

*** Archive files

#+BEGIN_SRC emacs-lisp
  (setq org-archive-location "%s_archive::")
#+END_SRC

*** GTD related

# In an effort to be more productive, I'm trying David Allen's "Getting Things
# Done" system, named after his book.
# 
# [[http://java.ociweb.com/mark/gtd.html][Here's a good summary of GTD]], if you're curious.
# 
# **** Agenda files
# 
# #+BEGIN_SRC emacs-lisp
#   (setq org-agenda-files '("~/org/gtd/gtd.org"))
# #+END_SRC
# 
# **** Stuck projects
# 
# #+BEGIN_SRC emacs-lisp
#   (setq org-stuck-projects '("/+PROJ" ("NEXT") nil nil))
# #+END_SRC
# 
# **** Custom agenda views
# 
# #+BEGIN_SRC emacs-lisp
#   (setq org-agenda-custom-commands
#         (quote
#          ((" " "Agenda"
#                ((agenda "" nil)
#                 (todo "NEXT"
#                       ((org-agenda-overriding-header "Next Actions")))
#                 (todo "PROJ"
#                       ((org-agenda-overriding-header "Projects"))))
#                nil)
#           ("n" "Next Actions" todo "NEXT" nil)
#           ("p" "Projects" todo "PROJ" nil)
#           ("s" "Someday" todo "SOMEDAY" nil))))
# #+END_SRC
# 
# **** Agenda follow-mode by default
# 
# Disabled for now
# 
# #+BEGIN_SRC emacs-lisp
#   ;; (setq org-agenda-start-with-follow-mode t)
# #+END_SRC

*** Prettier bullets

Automatically hides preceding asterisks, and makes the leading one
pretty.

#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
      :commands (org-bullets-mode)
      :init
      (setq org-bullets-bullet-list '("â"))
      (add-hook 'org-mode-hook #'org-bullets-mode))
#+END_SRC

*** Noticeable ellipsis

When headers are collapsed, =org-mode= uses ellipses to represent the hidden
text, but I think that's too subtle, so this makes them stand out more.

#+BEGIN_SRC emacs-lisp
  (setq org-ellipsis "â¢â¢â¢")
  ;; (setq org-ellipsis " é ")
#+END_SRC

*** Don't adapt indentation

The hierarchy of headers already does the job that indenting would do.

#+BEGIN_SRC emacs-lisp
  (setq org-adapt-indentation nil)
#+END_SRC

*** More convenient bindings

#+BEGIN_SRC emacs-lisp
  (general-define-key :keymaps 'org-mode-map
                      "C-c C-8" 'org-ctrl-c-star
                      "C-c 8" 'org-ctrl-c-star)
#+END_SRC

*** Global org bindings

These are available everywhere, even outside of org-mode.

#+BEGIN_SRC emacs-lisp
  (global-set-key "\C-cl" 'org-store-link)
  (global-set-key "\C-cc" 'org-capture)
  (global-set-key "\C-ca" 'org-agenda)
  (global-set-key "\C-cb" 'org-iswitchb)
#+END_SRC

*** Worf package

Worf is a minor mode for providing vi-like bindings for org-mode. However, I'm
only using it to take advantage of some of its nice functions.

#+BEGIN_SRC emacs-lisp
  (use-package worf
      :after (org)
      :commands (worf--ensure-visible))
#+END_SRC

*** Optimize org-babel config for faster startup

Running =org-babel-load-file= increases startup time, so only do it when there
are changes to update. (see [[file:init.el::%3B%3B%20`org-babel-load-file`%20increases%20startup%20time,%20so%20only%20do%20it%20if%20necessary.][init.el]])

**** Delete =config.el= when =config.org= is saved

#+BEGIN_SRC emacs-lisp
  (defun my/delete-config-el ()
    "Delete ~/.emacs.d/config.el when the current buffer is ~/.emacs.d/config.org"
    (setq configel "~/.emacs.d/config.el")
    (if (s-suffix? ".emacs.d/config.org" buffer-file-name)
        (if (file-exists-p configel)
            (delete-file "~/.emacs.d/config.el"))))

  (add-hook 'after-save-hook #'my/delete-config-el)
  (add-hook 'delayed-warnings-hook #'my/delete-config-el)
#+END_SRC

**** Tangle =config.org= on Emacs shutdown

But only when =config.el= is missing. Better to have a delayed shutdown than a
delayed startup.

#+BEGIN_SRC emacs-lisp
  (defun my/tangle-config ()
    "Convert (AKA \"tangle\") config.org into config.el"
    (if (not (file-exists-p "~/.emacs.d/config.el"))
        (org-babel-tangle-file "~/.emacs.d/config.org"
                               "~/.emacs.d/config.el"
                               "emacs-lisp")))

  (add-hook 'kill-emacs-hook #'my/tangle-config)
#+END_SRC

*** [[*Evil Org][Evil-mode compatibility]]

** Dired/Dired+

*** Enable find-alternate-file

Prevents dired from creating an annoying popup when =dired-find-alternate-file=
is called.

#+BEGIN_SRC emacs-lisp
  (put 'dired-find-alternate-file 'disabled nil)
#+END_SRC

*** Human readable filesize

#+BEGIN_SRC emacs-lisp
  (setq dired-listing-switches "-alh")
#+END_SRC

*** Recursive copy & delete

#+BEGIN_SRC emacs-lisp
  (setq dired-recursive-deletes 'always)
  (setq dired-recursive-copies 'always)
  (setq delete-by-moving-to-trash t
        trash-directory "~/.emacs.d/trash")
#+END_SRC

*** Open file with external application

#+BEGIN_SRC emacs-lisp
  (defun xah-open-in-external-app ()
    "Open the current file or dired marked files in external app.
  The app is chosen from your OS's preference.

  URL `http://ergoemacs.org/emacs/emacs_dired_open_file_in_ext_apps.html'
  Version 2015-01-26"
    (interactive)
    (let* (
           (Î¾file-list
            (if (string-equal major-mode "dired-mode")
                (dired-get-marked-files)
              (list (buffer-file-name))))
           (Î¾do-it-p (if (<= (length Î¾file-list) 5)
                         t
                       (y-or-n-p "Open more than 5 files? "))))

      (when Î¾do-it-p
        (cond
          ((string-equal system-type "windows-nt")
           (mapc
            (lambda (fPath)
              (w32-shell-execute "open" (replace-regexp-in-string "/" "\\" fPath t t))) Î¾file-list))
          ((string-equal system-type "darwin")
           (mapc
            (lambda (fPath) (shell-command (format "open \"%s\"" fPath)))  Î¾file-list))
          ((string-equal system-type "gnu/linux")
           (mapc
            (lambda (fPath) (let ((process-connection-type nil)) (start-process "" nil "xdg-open" fPath))) Î¾file-list))))))

  (general-define-key :keymaps 'dired-mode-map
                      "C-c C-o" 'xah-open-in-external-app)
#+END_SRC

*** Dired+

Dired enhancements.

#+BEGIN_SRC emacs-lisp
  (use-package dired+)
#+END_SRC

**** Omit mode

For hiding certain files and folders.

***** Files to omit

#+BEGIN_SRC emacs-lisp
  (use-package dired+
      :init
    ;; enable omit mode
    (setq-default dired-omit-mode t

                  ;; autosave files
                  dired-omit-files "^\\.?#"

                  ;; dot files
                  dired-omit-files
                  (concat dired-omit-files "\\|^\\.[^\\.]")))
#+END_SRC

***** Toggle omit binding

#+BEGIN_SRC emacs-lisp
  (use-package dired+
      :config
    (defun my/dired-omit-toggle ()
      (interactive)
      (if (bound-and-true-p dired-omit-mode)
          (progn (setq-default dired-omit-mode nil)
                 (dired-omit-mode -1))
        (progn (setq-default dired-omit-mode t)
               (dired-omit-mode 1))))
    (general-define-key :keymaps 'dired-mode-map
                        ")" 'my/dired-omit-toggle))
#+END_SRC

*** [[*Evil%20Dired][Evil-mode compatibility]]

** Ivy & Swiper

*** Autoload

#+BEGIN_SRC emacs-lisp
  (use-package swiper
      :commands (ivy-read)
      :bind (("C-h f" . counsel-describe-function)
             ("C-h v" . counsel-describe-variable)
             ("C-s" . swiper))
#+END_SRC

*** Options

#+BEGIN_SRC emacs-lisp
  :init
  (setq
   ;; recenter after swiper is finished
   swiper-action-recenter t

   ;; list recent files in buffer list as "virtual"
   ivy-use-virtual-buffers t

   ;; wrap around ivy results
   ivy-wrap t

   ;; display current candidate
   ivy-count-format "(%d/%d) "

   ;; no initial inputs
   ivy-initial-inputs-alist nil

   ;; use ivy as backend
   magit-completing-read-function 'ivy-completing-read
   projectile-completion-system 'ivy)
#+END_SRC

*** Activate

#+BEGIN_SRC emacs-lisp
  :config
  (ivy-mode 1)
  (diminish 'ivy-mode)
#+END_SRC

*** Ivy counsel

Adds enhanced ivy versions of many commands

#+BEGIN_SRC emacs-lisp
  (use-package counsel)
#+END_SRC

*** A nice ivy hydra

#+BEGIN_SRC emacs-lisp
  (use-package ivy-hydra))
#+END_SRC

*** [[*Evil%20Ivy%2BSwiper][Evil-mode compatibility]] 

** Magit

*** Autoload

#+BEGIN_SRC emacs-lisp
  (use-package magit
      :commands (magit-status
                 magit-diff
                 magit-commit
                 magit-log
                 magit-push
                 magit-stage-file
                 magit-unstage-file))
#+END_SRC

*** Use =ssh-agency= for Windows login prompt

Windows has issues allowing Magit to display prompts (when pushing a repo, for
example), so this package deals with that and fixes it somehow.

#+BEGIN_SRC emacs-lisp
  (use-package ssh-agency
      :after (magit)
      :init
      (setenv "SSH_ASKPASS" "git-gui--askpass"))
#+END_SRC

*** [[*Evil%20Magit][Vim-like leader bindings]]

*** See also: evil-magit under [[*Evil-specific%20packages][Evil-specific packages]]

** Projectile

*** Autoload

#+BEGIN_SRC emacs-lisp
  (use-package projectile
      :commands (projectile-global-mode)
      :bind-keymap ("C-c p" . projectile-command-map)
#+END_SRC

*** Activate

#+BEGIN_SRC emacs-lisp
  :config
  (projectile-mode t))
#+END_SRC

*** [[*Evil%20Projectile][Vim-like leader bindings]]

** Yasnippet

Snippets are located under the typical =~/.emacs.d/snippets=

#+BEGIN_SRC emacs-lisp
  ;; (use-package yasnippet
  ;;   :diminish yas-minor-mode
  ;;   :config
  ;;   (yas-global-mode 1))
#+END_SRC

* EVIL-MODE

Evil is so big and important that it gets its own top-level header. In all caps.

I used Vim for a couple years before Emacs (and still do), and that means I'm
cursed/blessed with modal editing for the rest of my life. Fortunately Evil is a
nearly exact Vim implementation, so all is well, and I can take advantage of
both editors with less mental strain.

** Compatibility with other modes

Create a list of functions to be ran when Evil-mode is activated. Each function
corresponds to a mode, and configures that mode to "be more evil."

The benefit of this is that I can pretty easily enable or disable all of
Evil-mode and keep it untangled from all other packages/modes. I don't know why
I would ever want to disable Evil-mode, but I can if I want, I guess.

*** Related variables

#+BEGIN_SRC emacs-lisp
  (setq my/evil-other-mode-funs ())
#+END_SRC

*** Built-in modes

See also: evil-special-modes under [[*Evil-specific%20packages][Evil-specific packages]]

Configure various modes that have little to configure and are built-in to Emacs.

#+BEGIN_SRC emacs-lisp
  (defun setup-evil-builtins ()
    ;; Special
    (evil-make-overriding-map special-mode-map 'normal)

    ;; Compilation
    (evil-set-initial-state 'compilation-mode 'normal)

    ;; Occur
    (evil-make-overriding-map occur-mode-map 'normal)
    (evil-set-initial-state 'occur-mode 'normal)

    ;; Bookmark
    (with-eval-after-load "bookmark"
      (evil-set-initial-state 'bookmark-bmenu-mode 'normal)
      (evil-make-overriding-map bookmark-bmenu-mode-map 'normal)
      (general-evil-define-key 'normal 'bookmark-bmenu-mode-map
        "RET" 'bookmark-bmenu-this-window
        "j" 'evil-next-line
        "k" 'evil-previous-line))

    ;;;; Package menu
    ;;(evil-set-initial-state 'package-menu-mode 'normal)
    ;;(evil-make-overriding-map package-menu-mode-map 'normal)
    ;;(general-evil-define-key 'normal 'package-menu-mode-map
    ;;  "U" 'package-menu-mark-upgrades)

    ;;;; Help
    ;;(general-evil-define-key 'normal 'help-mode-map
    ;;  "q" 'quit-window
    ;;  "<" 'help-go-back
    ;;  ">" 'help-go-forward)

    ;;;; Shells (all three of them)
    ;;(defun my/evil-shell-insert ()
    ;;  "Go to the very end of the buffer and enter insert state."
    ;;  (interactive)
    ;;  (evil-goto-line)
    ;;  (evil-append-line 0))
    ;;(general-evil-define-key 'normal
    ;;    '(shell-mode-map eshell-mode-map term-mode-map)
    ;;  "I" 'my/evil-shell-insert
    ;;  "A" 'my/evil-shell-insert)
    )
  (add-to-list 'my/evil-other-mode-funs 'setup-evil-builtins)
#+END_SRC

*** Evil Org

I know org-mode is built-in, but it's so big that it's like a separate entity to me.

#+BEGIN_SRC emacs-lisp
  (defun setup-evil-org-mode ()
    (with-eval-after-load "org"
      (defhydra hydra-org-nav (:color red :hint nil)
        "
   ^Nav^   ^^^^| ^View^           ^^| ^Search^   | ^Exit Hydra
  -^---^---^^^^+-^----^-----------^^+-^------^---+-^-----------
   ^ ^ _k_ ^ ^ | _o_pen (_a_ppear), | _g_oto     | _b_ack_._
   _h_ ^+^ _l_ | hi_d_e,  _c_ycle,  | _s_wiper   | _q_uit_._
   ^ ^ _j_ ^ ^ | ^globally^ _C_ycle | ^ ^        |
  "
        ("j" outline-next-visible-heading)
        ("J" worf-down)
        ("k" outline-previous-visible-heading)
        ("K" worf-up)
        ("h" worf-left)
        ("l" worf-right)
        ("a" my/show-header)
        ("o" my/show-header)
        ("d" hide-subtree)
        ("c" org-cycle)
        ("C" org-shifttab)
        ("g" org-goto :exit t)
        ("s" swiper)
        ("q" nil) ("b" nil) ("." nil))

      (defhydra hydra-org-action (:color blue :columns 5)
        "Org Actions:"
        ("c" org-ctrl-c-ctrl-c "C-c C-c")
        ("t" org-todo "todo")
        ("w" org-refile "move")
        ("d" org-deadline "deadline")
        ("q" nil "quit")
        ("s" org-schedule "schedule")
        ("a" org-agenda "agenda")
        ("n" org-add-note "note")
        ("x" org-archive-subtree "archive"))

      (defun my/show-header ()
        (interactive)
        (show-children)
        (show-entry))

      (defhydra hydra-org-template (:color blue :hint nil)
        "
  _c_enter  _q_uote     _e_macs-lisp    _L_aTeX:
  _l_atex   _E_xample   _p_erl          _i_ndex:
  _a_scii   _v_erse     _P_erl tangled  _I_NCLUDE:
  _s_rc     ^ ^         plant_u_ml      _H_TML:
  _h_tml    ^ ^         ^ ^             _A_SCII:
  "
        ("s" (hot-expand "<s"))
        ("E" (hot-expand "<e"))
        ("q" (hot-expand "<q"))
        ("v" (hot-expand "<v"))
        ("c" (hot-expand "<c"))
        ("l" (hot-expand "<l"))
        ("h" (hot-expand "<h"))
        ("a" (hot-expand "<a"))
        ("L" (hot-expand "<L"))
        ("i" (hot-expand "<i"))
        ("e" (hot-expand "<s" "emacs-lisp"))
        ("p" (hot-expand "<s" "perl"))
        ("u" (hot-expand "<s" "plantuml :file CHANGE.png"))
        ("P" (progn
               (insert "#+HEADERS: :results output :exports "
                       (insert "both :shebang \"#!/usr/bin/env perl\"\n")
                       (hot-expand "<s" "perl"))))
        ("I" (hot-expand "<I"))
        ("H" (hot-expand "<H"))
        ("A" (hot-expand "<A"))
        ("<" self-insert-command "ins")
        ("o" nil "quit"))

      (defun hot-expand (str &optional mod)
        "Expand org template."
        (insert str)
        (org-try-structure-completion)
        (when mod (insert mod) (forward-line)))

      (defun call-hydra-org-template ()
        (interactive)
        (if (looking-back "^")
            (hydra-org-template/body)
          (self-insert-command 1)))

      (general-evil-define-key 'normal 'org-mode-map
        "RET" 'org-open-at-point
        ">" 'outline-demote
        "<" 'outline-promote
        "s" 'hydra-org-action/body
        "z g" 'org-goto
        "z x" 'hydra-org-nav/body
        "z j" 'hydra-org-nav/outline-next-visible-heading
        "z k" 'hydra-org-nav/outline-previous-visible-heading
        "z h" 'hydra-org-nav/worf-left
        "z l" 'hydra-org-nav/worf-right)
      (general-evil-define-key 'insert 'org-mode-map
        "C-t" 'outline-demote
        "C-d" 'outline-promote
        "<" 'call-hydra-org-template)
      (general-evil-define-key '(normal visual insert) 'org-mode-map
        "M-h" 'org-metaleft
        "M-j" 'org-metadown
        "M-k" 'org-metaup
        "M-l" 'org-metaright
        "M-S-h" 'org-shiftmetaleft
        "M-S-j" 'org-shiftmetadown
        "M-S-k" 'org-shiftmetaup
        "M-S-l" 'org-shiftmetaright
        "C-S-h" 'org-shiftcontrolleft
        "C-S-j" 'org-shiftcontroldown
        "C-S-k" 'org-shiftcontrolup
        "C-S-l" 'org-shiftcontrolright)

      ;; Reveal cursor when going to marks
      (defun my/reveal-cursor (&rest _)
        (worf--ensure-visible))
      (advice-add 'evil-goto-mark :after #'my/reveal-cursor)

      (defun my/fix-org-evil-paragraphs ()
        "Make Evil mode's paragraph motions work correctly in Org mode."
        (setq paragraph-start "\\|[     ]*$"
              paragraph-separate "[       ]*$"))

      ;; Swap j/k and n/p
      (general-define-key :keymaps 'org-agenda-mode-map
                          "j" 'org-agenda-next-line
                          "k" 'org-agenda-previous-line
                          "n" 'org-agenda-goto-date
                          "p" 'org-agenda-capture)

      (add-hook 'org-mode-hook #'my/fix-org-evil-paragraphs)))
  (add-to-list 'my/evil-other-mode-funs 'setup-evil-org-mode)
#+END_SRC

*** Evil Ibuffer

#+BEGIN_SRC emacs-lisp
  (defun setup-evil-ibuffer-mode ()
    (with-eval-after-load "ibuffer"
      (evil-set-initial-state 'ibuffer-mode 'normal)
      (evil-make-overriding-map ibuffer-mode-map 'normal)
      (defhydra hydra-ibuffer-main (:color pink :hint nil)
        "
   ^Navigation^ | ^Mark^        | ^Actions^        | ^View^
  -^----------^-+-^----^--------+-^-------^--------+-^----^-------
    _k_:    Ê   | _m_: mark     | _D_: delete      | _g_: refresh
   _RET_: visit | _u_: unmark   | _S_: save        | ^s^: sort
    _j_:    v   | ^*^: specific | _a_: all actions | ^/^: filter
  -^----------^-+-^----^--------+-^-------^--------+-^----^-------
  "
        ("j" ibuffer-forward-line)
        ("RET" ibuffer-do-view :color blue)
        ("k" ibuffer-backward-line)

        ("m" ibuffer-mark-forward)
        ("u" ibuffer-unmark-forward)

        ("D" ibuffer-do-delete)
        ("S" ibuffer-do-save)
        ("a" hydra-ibuffer-action/body :color blue)

        ("g" ibuffer-update)

        ("o" ibuffer-visit-buffer-other-window "other window" :color blue)
        ("q" quit-window "quit ibuffer" :color blue)
        ("." nil "toggle hydra" :color blue))

      (defhydra hydra-ibuffer-action (:color teal :columns 4
                                      :after-exit
                                      (if (eq major-mode 'ibuffer-mode)
                                          (hydra-ibuffer-main/body)))
        "Action"
        ("A" ibuffer-do-view "view")
        ("E" ibuffer-do-eval "eval")
        ("F" ibuffer-do-shell-command-file "shell-command-file")
        ("I" ibuffer-do-query-replace-regexp "query-replace-regexp")
        ("H" ibuffer-do-view-other-frame "view-other-frame")
        ("N" ibuffer-do-shell-command-pipe-replace "shell-cmd-pipe-replace")
        ("M" ibuffer-do-toggle-modified "toggle-modified")
        ("O" ibuffer-do-occur "occur")
        ("P" ibuffer-do-print "print")
        ("Q" ibuffer-do-query-replace "query-replace")
        ("R" ibuffer-do-rename-uniquely "rename-uniquely")
        ("T" ibuffer-do-toggle-read-only "toggle-read-only")
        ("U" ibuffer-do-replace-regexp "replace-regexp")
        ("V" ibuffer-do-revert "revert")
        ("W" ibuffer-do-view-and-eval "view-and-eval")
        ("X" ibuffer-do-shell-command-pipe "shell-command-pipe")
        ("b" nil "back"))

      (general-evil-define-key 'normal 'ibuffer-mode-map
        "." 'hydra-ibuffer-main/body)
      (add-hook 'ibuffer-hook #'hydra-ibuffer-main/body)))
  (add-to-list 'my/evil-other-mode-funs 'setup-evil-ibuffer-mode)
#+END_SRC

*** Evil Dired

Directory climbing inspired by [[https://github.com/tpope/vim-vinegar][tpope's vinegar]].

#+BEGIN_SRC emacs-lisp
  (defun setup-evil-dired-mode ()
    (with-eval-after-load "dired"
      (defun my/up-dir ()
        (interactive)
        (find-alternate-file ".."))

      (defhydra hydra-dired-main (:color pink :hint nil)
        "
   ^Navigation^ | ^Mark^        | ^Actions^        | ^View^
  -^----------^-+-^----^--------+-^-------^--------+-^----^-------
    _k_:    Ê   | _m_: mark     | _D_: delete      | _g_: refresh
   _RET_: visit | _u_: unmark   | _S_: save        | ^s^: sort
    _j_:    v   | ^*^: specific | ^a^: all actions | ^/^: filter
  -^----------^-+-^----^--------+-^-------^--------+-^----^-------
  "
        ("-" my/up-dir)
        ("j" dired-next-line)
        ("RET" dired-find-alternate-file :color blue)
        ("k" dired-previous-line)

        ("m" dired-mark)
        ("u" dired-unmark-forward)
        ;("*" hydra-dired-mark/body :color blue)

        ("D" dired-do-delete)
        ("S" dired-do-save)
        ;("a" hydra-dired-action/body :color blue)

        ("g" dired-update)
        ;("s" hydra-dired-sort/body :color blue)
        ;("/" hydra-dired-filter/body :color blue)

        ("o" dired-find-file-other-window :color blue)
        ("q" quit-window "quit dired" :color blue)
        ("." nil "toggle hydra" :color blue))

      (defhydra hydra-dired-action (:color teal :columns 4
                                    :after-exit
                                    (if (eq major-mode 'dired-mode)
                                        (hydra-dired-main/body)))
        "Action"
        ("X" dired-do-shell-command-pipe "shell-command-pipe")
        ("b" nil "back"))

      (evil-make-overriding-map dired-mode-map 'normal)
      (general-define-key :states 'normal "-" (kbd "C-x d RET"))
      (general-evil-define-key 'normal 'dired-mode-map
        "-" 'my/up-dir
        "RET" 'dired-find-alternate-file
        "i" 'ido-find-file
        "j" 'dired-next-line
        "k" 'dired-previous-line
        "gg" 'evil-goto-first-line
        "G" 'evil-goto-line
        "." 'hydra-dired-main/body)
      ))
  (add-to-list 'my/evil-other-mode-funs 'setup-evil-dired-mode)
#+END_SRC

*** Evil Ivy+Swiper

#+BEGIN_SRC emacs-lisp
  (defun setup-evil-ivyswiper-mode ()
    ;; Vimish bindings
    (general-define-key
     :keymaps 'ivy-minibuffer-map
     "C-j" 'ivy-next-line
     "C-k" 'ivy-previous-line
     "C-n" 'ivy-next-history-element
     "C-p" 'ivy-previous-history-element
     "<C-return>" 'ivy-immediate-done
     "C-l" 'ivy-immediate-done
     "C-w" 'ivy-backward-kill-word)
    (general-define-key
     :keymaps 'swiper-map
     "C-r" 'swiper-query-replace)

    ;; Leader shortcuts
    (general-define-key
     :states '(normal motion emacs)
     :prefix "SPC"
     "SPC"  'counsel-M-x
     "b" 'ivy-switch-buffer
     "f" 'counsel-find-file
     ))
  (add-to-list 'my/evil-other-mode-funs 'setup-evil-ivyswiper-mode)
#+END_SRC

*** Evil Magit

(not to be confused with the package, evil-magit)

#+BEGIN_SRC emacs-lisp
  (defun setup-evil-magit-mode ()
    (evil-set-initial-state 'magit-mode 'emacs)
    ;; Leader shortcuts
    (general-define-key
     :states '(normal motion emacs)
     :prefix "SPC"
     "gs" 'magit-status
     "gd" 'magit-diff
     "gc" 'magit-commit
     "gl" 'magit-log
     "gp" 'magit-push
     ;; "gw" 'magit-stage-file   ;; "write"
     ;; "gr" 'magit-unstage-file ;; "remove"
     "gg" 'vc-git-grep))
  (add-to-list 'my/evil-other-mode-funs 'setup-evil-magit-mode)
#+END_SRC

*** Evil Projectile

#+BEGIN_SRC emacs-lisp
  (defun setup-evil-projectile-mode ()
    ;; Leader shortcuts
    (general-define-key
     :states '(normal motion emacs)
     :prefix "SPC"
     "p"  (general-simulate-keys "C-c p")))
  (add-to-list 'my/evil-other-mode-funs 'setup-evil-projectile-mode)
#+END_SRC

*** Evil Info

#+BEGIN_SRC emacs-lisp
  ;;  (defun setup-evil-info-mode ()
  ;;    (defhydra hydra-info (:color red
  ;;                          :hint nil)
  ;;      "
  ;;  Info-mode:

  ;;    ^^_]_ forward  (next logical node)       ^^_l_ast (â)        _u_p (â)                             _f_ollow reference       _T_OC
  ;;    ^^_[_ backward (prev logical node)       ^^_r_eturn (â)      _m_enu (â) (C-u for new window)      _i_ndex                  _d_irectory
  ;;    ^^_n_ext (same level only)               ^^_H_istory         _g_oto (C-u for new window)          _,_ next index item      _c_opy node name
  ;;    ^^_p_rev (same level only)               _<_/_t_op           _b_eginning of buffer                virtual _I_ndex          _C_lone buffer
  ;;    regex _s_earch (_S_ case sensitive)      ^^_>_ final         _e_nd of buffer                      ^^                       _a_propos

  ;;    _1_ .. _9_ Pick first .. ninth item in the node's menu.
  ;;  "
  ;;      ("]"   Info-forward-node)
  ;;      ("["   Info-backward-node)
  ;;      ("n"   Info-next)
  ;;      ("p"   Info-prev)
  ;;      ("s"   Info-search)
  ;;      ("S"   Info-search-case-sensitively)

  ;;      ("l"   Info-history-back)
  ;;      ("r"   Info-history-forward)
  ;;      ("H"   Info-history)
  ;;      ("t"   Info-top-node)
  ;;      ("<"   Info-top-node)
  ;;      (">"   Info-final-node)

  ;;      ("u"   Info-up)
  ;;      ("^"   Info-up)
  ;;      ("m"   Info-menu)
  ;;      ("g"   Info-goto-node)
  ;;      ("b"   beginning-of-buffer)
  ;;      ("e"   end-of-buffer)

  ;;      ("f"   Info-follow-reference)
  ;;      ("i"   Info-index)
  ;;      (","   Info-index-next)
  ;;      ("I"   Info-virtual-index)

  ;;      ("T"   Info-toc)
  ;;      ("d"   Info-directory)
  ;;      ("c"   Info-copy-current-node-name)
  ;;      ("C"   clone-buffer)
  ;;      ("a"   info-apropos)

  ;;      ("1"   Info-nth-menu-item)
  ;;      ("2"   Info-nth-menu-item)
  ;;      ("3"   Info-nth-menu-item)
  ;;      ("4"   Info-nth-menu-item)
  ;;      ("5"   Info-nth-menu-item)
  ;;      ("6"   Info-nth-menu-item)
  ;;      ("7"   Info-nth-menu-item)
  ;;      ("8"   Info-nth-menu-item)
  ;;      ("9"   Info-nth-menu-item)

  ;;      ("?"   Info-summary "Info summary")
  ;;      ("h"   Info-help "Info help")
  ;;      ("q"   Info-exit "Info exit" :color blue)
  ;;      ("." nil "toggle hydra" :color blue))
  ;;    (general-evil-define-key 'normal 'Info-mode-map
  ;;      "." 'hydra-info/body
  ;;      "TAB" 'Info-next-reference
  ;;      "S-TAB" 'Info-prev-reference
  ;;      "RET" 'Info-follow-nearest-node
  ;;      "C-p" 'Info-history-back
  ;;      "C-n" 'Info-history-forward
  ;;      "q" 'Info-exit))
  ;;(add-to-list 'my/evil-other-mode-funs 'setup-evil-info-mode)
#+END_SRC

** Basic options

#+BEGIN_SRC emacs-lisp
  (use-package evil
      :init
      (setq evil-want-C-w-delete t
            evil-want-fine-undo "No"
            evil-want-Y-yank-to-eol t
            evil-want-C-u-scroll t
            evil-ex-substitute-global t
            evil-overriding-maps nil
            evil-search-module 'evil-search)

      ;;;; Persistent undo history (save info to file)
      ;;(setq undo-tree-auto-save-history t
      ;;      undo-tree-history-directory-alist `((".*" . "~/.emacs.d/tmp")))
      )
#+END_SRC

** Disable evil-make-overriding/intercept-map at start-up.

Otherwise, Evil will mess with other mode's mappings.

#+BEGIN_SRC emacs-lisp
  (use-package evil
      :init
    (advice-add 'evil-make-intercept-map :override #'ignore)
    (advice-add 'evil-make-overriding-map :override #'ignore))
#+END_SRC

** Post-activation setup function

Runs after Evil-mode is activated, and contains mostly all of my configuration
for Evil.

*** START function

#+BEGIN_SRC emacs-lisp
  (defun setup-evil-settings ()
#+END_SRC

*** General settings

**** Cursor color/shape to indicate modes/states

Match GVim's cursor shapes.

#+BEGIN_SRC emacs-lisp
  (setq evil-normal-state-cursor   '("dodger blue" box)
        evil-insert-state-cursor   '("dodger blue" bar)
        evil-replace-state-cursor  '("dodger blue" hbar)
        evil-operator-state-cursor '("dodger blue" (hbar . 7))
        evil-visual-state-cursor   '("orange" box)
        evil-motion-state-cursor   '("deep pink" box)
        evil-emacs-state-cursor    '("red2" box))
#+END_SRC

**** Auto-switch to help window like Vim

#+BEGIN_SRC emacs-lisp
  (setq help-window-select t)
#+END_SRC

**** Dehighlight search when finished searching

#+BEGIN_SRC emacs-lisp
  (defun my/evil-search-nohl-on-move ()
    "Dehighlight Evil ex search when any keys other than n or N are pressed."
    (interactive)
    (if (not (or (equal (this-command-keys) "n")
                 (equal (this-command-keys) "N")))
        (progn (evil-ex-nohighlight)
               (remove-hook 'pre-command-hook
                            'my/evil-search-nohl-on-move))))

  (defun my/add-hook-evil-search (&rest _)
    (add-hook 'pre-command-hook #'my/evil-search-nohl-on-move))

  (advice-add 'evil-ex-start-search :after #'my/add-hook-evil-search)
  (advice-add 'evil-ex-search :after #'my/add-hook-evil-search)
#+END_SRC

**** Center view advice

Center the view when certain functions are called.

#+BEGIN_SRC emacs-lisp
  (setq my/funs-to-center '(evil-ex-search
                            evil-ex-start-search
                            evil-goto-line
                            evil-goto-mark
                            evil-goto-mark-line))

  (defun my/scroll-to-center (&rest _)
    (evil-scroll-line-to-center nil))

  (dolist (fun my/funs-to-center)
    (advice-add fun :after #'my/scroll-to-center))
#+END_SRC

**** clear trailing whitespace ex command

#+BEGIN_SRC emacs-lisp
  (evil-ex-define-cmd "ctw" 'delete-trailing-whitespace)
#+END_SRC

**** Re-enable evil-make-overriding/intercept-map

They were disabled before so that I can have complete control over key bindings.
They're being enabled again so that I can make use of them.

#+BEGIN_SRC emacs-lisp
  (advice-remove 'evil-make-overriding-map #'ignore)
  (advice-remove 'evil-make-intercept-map #'ignore)
#+END_SRC

*** Global bindings

These are mostly remaps and convenience shortcuts for Evil mode.

**** Make defining bindings more vim-like with [[*Enhanced%20key%20binding][general.el]]

=nmap= looks so much nicer than =general-define-key :states 'normal=.

#+BEGIN_SRC emacs-lisp
  (general-evil-setup t 'current-global-map)
#+END_SRC

**** In case M-x is weirdly undefined

#+BEGIN_SRC emacs-lisp
  (nmap "M-x" 'execute-extended-command)
#+END_SRC

**** Back to last buffer

#+BEGIN_SRC emacs-lisp
  (nmap "DEL" 'evil-switch-to-windows-last-buffer)
#+END_SRC

**** U instead of C-r for redo

#+BEGIN_SRC emacs-lisp
  (nmap "U" 'redo)
#+END_SRC

**** Q to replay q register

#+BEGIN_SRC emacs-lisp
  (nmap "Q" "@q")
#+END_SRC

**** [S]plit Line (sister to [J]oin Line)

#+BEGIN_SRC emacs-lisp
  (defun my/split-line ()
    (interactive)
    (newline-and-indent) (forward-line -1) (move-end-of-line 1))
  (nmap "S" 'my/split-line )
#+END_SRC

**** =_= and =|= to split windows

also focus on the new split window like Vim

#+BEGIN_SRC emacs-lisp
  (defun evil-window-split ()
    "Split current window vertically and focus on the new window."
    (interactive)
    (split-window-vertically)
    (other-window 1))
  (defun evil-window-vsplit ()
    "Split current window horizontally and focus on the new window."
    (interactive)
    (split-window-horizontally)
    (other-window 1))
  (nmap "|" 'evil-window-vsplit
        "_" 'evil-window-split)
#+END_SRC

**** Jump list (previous, next)

#+BEGIN_SRC emacs-lisp
  (nmap "C-p" 'evil-jump-backward
        "C-n" 'evil-jump-forward)
#+END_SRC

**** Move by wrapped lines, not by line numbers

#+BEGIN_SRC emacs-lisp
  (general-mmap "j" 'evil-next-visual-line
                "k" 'evil-previous-visual-line
                "gj" 'evil-next-line
                "gk" 'evil-previous-line)
#+END_SRC

**** gb for simple buffer management

#+BEGIN_SRC emacs-lisp
  (nmap "gb" 'buffer-menu)
#+END_SRC

**** Go to the end of pasted text

#+BEGIN_SRC emacs-lisp
  (defun my/cursor-to-end-of-paste (&rest _)
    (let ((marker (evil-get-marker ?\])))
      (goto-char marker)))
  (advice-add 'evil-paste-after :after #'my/cursor-to-end-of-paste)
#+END_SRC

**** Convenient scrolling

Aside from being more comfortable, this keeps standard =C-u=
(universal-argument) available.

#+BEGIN_SRC emacs-lisp
  (nmap "C-j" 'evil-scroll-down
        "C-k" 'evil-scroll-up)
#+END_SRC

**** evil-Sayonara

A rip-off of [[https://github.com/mhinz/vim-sayonara][vim-sayonara]], and a WIP

TODO: 
- fix destroy bugs
- make preserve not kill if the current buffer is visible elsewhere
  - (window-buffer WINDOW) finds buffer of window
  - somehow check buffers of all other windows

#+BEGIN_SRC emacs-lisp
  (defun my/sayonara-destroy ()
    "Kill buffer and window, if it's not the last split."
    (interactive "p")
    (dolist (buf (buffer-list (selected-frame)))
      (let ((win (get-buffer-window buf)))
        (kill-buffer (current-buffer))
        (window--delete))))

  (defun my/sayonara-preserve ()
    "Kill buffer, but always keep window"
    (interactive "p")
    (kill-this-buffer))

  (nmap "gs" 'my/sayonara-destroy
        "gS" 'my/sayonara-preserve)
#+END_SRC

**** evil-unimpaired

Inspired by [[https://github.com/tpope/vim-unimpaired][unimpaired]]

***** Insert blank lines

Like using =o= or =O=, but doesn't enter insert mode.

#+BEGIN_SRC emacs-lisp
  (defun my/evil-blank-above (count)
    "Add [count] blank lines above the point."
    (interactive "p")
    (setq col (current-column))
    (while (> count 0)
      (evil-insert-newline-above)
      (forward-line 1)
      (add-hook 'post-command-hook #'evil-maybe-remove-spaces)
      (setq count (- count 1)))
    (move-to-column col))
  (defun my/evil-blank-below (count)
    "Add [count] blank lines below the point."
    (interactive "p")
    (setq col (current-column))
    (while (> count 0)
      (evil-insert-newline-below)
      (forward-line -1)
      (add-hook 'post-command-hook #'evil-maybe-remove-spaces)
      (setq count (- count 1)))
    (move-to-column col))

  (nmap "[ SPC" 'my/evil-blank-above
        "] SPC" 'my/evil-blank-below
        "[ b" 'previous-buffer
        "] b" 'next-buffer)
#+END_SRC

***** Formatted, line-wise paste

Same as =\=p= unimpaired. This implementation is so bad that it's disabled until
I make a better one. If anyone has any ideas, message me about it or make a pull
request.

#+BEGIN_SRC emacs-lisp
  ;;(nmap "gp" (general-simulate-keys "] SPC jp`[V`]=gvdP"))
#+END_SRC

**** C-g to see total line numbers like Vim

#+BEGIN_SRC emacs-lisp
  (nmap "C-g" 'count-words)
#+END_SRC

**** Insert movement

#+BEGIN_SRC emacs-lisp
  (imap "C-a" 'move-beginning-of-line
        "C-e" 'move-end-of-line)
#+END_SRC

**** Always cancel/escape to normal state

#+BEGIN_SRC emacs-lisp
  (general-define-key :states '(visual insert replace motion)
                      "C-g" 'evil-normal-state
                      "C-[" 'evil-normal-state)
#+END_SRC

**** "entire" text object (ae and ie)

For operating on the entire file.

(require 'evil-textobj-entire)

#+BEGIN_SRC emacs-lisp
  (use-package evil-textobj-entire
      :load-path "~/.emacs.d/elisp/"
      :ensure nil)
#+END_SRC

*** Leader bindings

The "leader" key is a concept from Vim, and it's just a global prefix key like
=C-x= or =C-c=, but for personal use. I use the spacebar as my primary leader
key, and [[https://github.com/noctuid/general.el][general.el]] to make it easy.

Leader bindings may be defined for other packages under [[*Compatibility%20with%20other%20modes][their own configuration]].

#+BEGIN_SRC emacs-lisp
  (defun my/open-init-el ()
    (interactive)
    (find-file "~/.emacs.d/config.org"))
  (defun my/open-gtd ()
    (interactive)
    (find-file "~/org/gtd/gtd.org"))

  (defhydra hydra-toggle-option (:color blue)
    "Toggle"
    ("v" visual-line-mode "visual-line-mode")
    ("t" toggle-truncate-lines "truncate lines")
    ("w" toggle-word-wrap "word wrap")
    ("W" whitespace-mode "whitespace-mode")
    ("n" linum-mode "linum-mode")
    ("l" lispyville-mode "lispyville-mode")
    ;; TODO: look into cross-platform spell checker
    ("s" flyspell-mode "spell check"))

  (general-override-mode)
  (general-define-key
    :states '(normal motion emacs)
    :keymaps 'override
    :prefix "SPC"

   ;;  Avoiding CTRL
   "w" (general-simulate-keys "C-w" nil nil t)
   "x" (general-simulate-keys "C-x" nil nil t)
   "c" (general-simulate-keys "C-c" nil nil t)
   "h" (general-simulate-keys "C-h" nil nil t)

   ;; The Rest
   "TAB" 'other-window
   "s"  'evil-write
   "e"  'eval-last-sexp
   "E"  'pp-macroexpand-last-sexp
   "q"  'quit-window
   "f"  'ido-find-file
   "b"  'ido-switch-buffer
   "B"  'ibuffer
   "P"  'list-packages
   "o"  'hydra-toggle-option/body
   "m"  'evil-motion-state
   "i"  'my/open-init-el
   "G"  'my/open-gtd
   "I"  'emacs-init-time)

#+END_SRC

*** Run compatibility functions

Run a list of functions to make other modes "more evil." See [[Compatibility with
other modes]].

#+BEGIN_SRC emacs-lisp
  (dolist (fun my/evil-other-mode-funs) (funcall fun))
#+END_SRC

*** END function

#+BEGIN_SRC emacs-lisp
  )
#+END_SRC

** Hook to configure Evil after activation

#+BEGIN_SRC emacs-lisp
  (eval-after-load "evil" (add-hook 'evil-mode-hook #'setup-evil-settings))
#+END_SRC

** Evil-specific packages

*** [[https://github.com/jojojames/evil-collection][evil-collection]]

Creates consistent evil bindings for many built-in modes.
Currently an early WIP

#+BEGIN_SRC emacs-lisp
  (use-package evil-collection
      :load-path "~/.emacs.d/elisp/evil-collection"
      :config
      :ensure nil)
#+END_SRC

*** [[https://github.com/Ambrevar/evil-special-modes][evil-special-modes]]

Creates consistent evil bindings for many built-in modes.
Currently an early WIP

#+BEGIN_SRC emacs-lisp
  (use-package evil-special-modes
      :load-path "~/.emacs.d/elisp/evil-special-modes"
      :config
      ;;(with-eval-after-load 'calendar   (require 'evil-calendar) (evil-calendar-set-keys))
      ;;(with-eval-after-load 'cus-edit   (require 'evil-custom) (evil-custom-set-keys))
      ;;(with-eval-after-load 'debug      (require 'evil-debugger) (evil-debugger-set-keys))
      ;;(with-eval-after-load 'diff-mode  (require 'evil-diff-mode) (evil-diff-mode-set-keys))
      ;;(with-eval-after-load 'eshell     (require 'evil-eshell) (evil-eshell-set-keys))
      ;;(with-eval-after-load 'help       (require 'evil-help) (evil-help-set-keys))
      ;;(with-eval-after-load 'image-mode (require 'evil-image) (evil-image-set-keys))
      ;;(with-eval-after-load 'info       (require 'evil-info) (evil-info-set-keys))
      ;;(with-eval-after-load 'man        (require 'evil-man) (evil-man-set-keys))
      ;;(with-eval-after-load 'package    (require 'evil-package) (evil-package-set-keys))
      ;;(with-eval-after-load 'proced     (require 'evil-proced) (evil-proced-set-keys))
      ;;(with-eval-after-load 'profiler   (require 'evil-profiler) (evil-profiler-set-keys))
      ;;(with-eval-after-load 'term       (require 'evil-term) (evil-term-set-keys))
      ;;(with-eval-after-load 'woman (require 'evil-woman) (evil-woman-set-keys))
      :ensure nil)
#+END_SRC

*** [[https://github.com/justbur/evil-magit][evil-magit]]

Modifies some Magit bindings to be more Evil

#+BEGIN_SRC emacs-lisp
  (use-package evil-magit
      :init (setq evil-magit-state 'emacs)
      :after evil magit)
#+END_SRC

*** [[https://github.com/timcharper/evil-surround][evil-surround]]

Manipulate surroundings

#+BEGIN_SRC emacs-lisp
  (use-package evil-surround
      :after evil
      :config
      (global-evil-surround-mode))
#+END_SRC

*** [[https://github.com/Dewdrops/evil-exchange][evil-exchange]]

Exchange operator

#+BEGIN_SRC emacs-lisp
  (use-package evil-exchange
      :after evil
      :config
      ;; "[g]o e[x]change"
      ;; gX is cancel
      (evil-exchange-install))
#+END_SRC

*** [[https://github.com/redguardtoo/evil-nerd-commenter][evil-nerd-commenter]]

Comment operator

#+BEGIN_SRC emacs-lisp
  (use-package evil-nerd-commenter
      :after evil
      :config
      (general-define-key :states '(normal visual) "gc"
                          'evilnc-comment-operator))
#+END_SRC

*** [[https://github.com/bling/evil-visualstar][evil-visualstar]]

Make a visual selection, and search it. Convenient and intuitive.

#+BEGIN_SRC emacs-lisp
  (use-package evil-visualstar
      :after evil
      :config
      (global-evil-visualstar-mode))
#+END_SRC

*** [[https://github.com/CodeFalling/nlinum-relative][nlinum-relative]]

Relative line numbers

#+BEGIN_SRC emacs-lisp
  (use-package nlinum-relative
      :after evil
      :init
      (setq nlinum-relative-current-symbol "->")
      :config
      (add-hook 'prog-mode-hook #'nlinum-relative-mode)
      ;; No bold!
      (custom-set-faces
       '(nlinum-relative-current-face ((t (:weight normal))))))
#+END_SRC

*** [[https://github.com/noctuid/emacs-sentence-navigation][emacs-sentence-navigation]]

Improved sentence logic and navigation.

#+BEGIN_SRC emacs-lisp
  (use-package sentence-navigation
      :after evil
      :config
      (define-key evil-normal-state-map ")" 'sentence-nav-evil-forward)
      (define-key evil-normal-state-map "(" 'sentence-nav-evil-backward)
      (define-key evil-normal-state-map "g)" 'sentence-nav-evil-forward-end)
      (define-key evil-normal-state-map "g(" 'sentence-nav-evil-backward-end)
      (define-key evil-outer-text-objects-map "s" 'sentence-nav-evil-outer-sentence)
      (define-key evil-inner-text-objects-map "s" 'sentence-nav-evil-inner-sentence))
#+END_SRC

*** [[https://github.com/noctuid/lispyville][lispyville]]

# Better lisp editing for Evil. (With some help from [[https://github.com/abo-abo/lispy][lispy]])
# 
# #+BEGIN_SRC emacs-lisp
#   (defun my/load-lispy ()
#     (interactive)
#     (lispyville-mode)
#     (diminish 'lispyville-mode))
#   (use-package lispy
#       :after evil
#       :commands (lispyville-mode)
#       :config
#       (load-file "~/.emacs.d/elisp/lispyville.el")
#       (lispyville-set-key-theme '(slurp/barf-cp)))
#   (add-hook 'lisp-mode-hook #'my/load-lispy)
#   (add-hook 'emacs-lisp-mode-hook #'my/load-lispy)
# #+END_SRC

** Activate Evil

#+BEGIN_SRC emacs-lisp
  (evil-mode 1)
#+END_SRC

