#+TITLE: An Emacs Config
#+AUTHOR: Austin Smith
#+EMAIL: AssailantLF@gmail.com

* Preamble

This is my Emacs config, which is (pretty much) in a single file thanks to
[[http://orgmode.org/worg/org-contrib/babel/intro.html][org-babel]].

Although GitHub does render =.org= files nicely, I recommend viewing it in
Emacs, as GitHub isn't fully compatible. Using org-mode gives a nice overview
and makes it quick and easy to navigate and make changes.

* Package related

Setup general package related settings.

** package.el

Initialize package.el, the built-in package manager

#+BEGIN_SRC emacs-lisp
  (package-initialize)
#+END_SRC

These are the package repositories I use:

#+BEGIN_SRC emacs-lisp
  (setq package-archives '(("gnu" . "http://elpa.gnu.org/packages/")
                           ("melpa" . "http://melpa.org/packages/")
                           ("melpa-stable" . "http://stable.melpa.org/packages/")))
#+END_SRC

** [[https://github.com/jwiegley/use-package][use-package]]

Makes installing and configuring other packages nicer and easier. It also helps
with autoloading packages to greatly reduce initial startup time. The following
snippet automatically installs use-package if it isn't already installed.

#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
  (require 'use-package)
  (setq use-package-always-ensure t)
#+END_SRC

* Appearance related

Setup appearance early so that if something goes wrong with the init, Emacs is
still lookin' good. These settings (mostly) shouldn't affect any functionality.

** Maximize Emacs on startup

This snippet works in *nix and all (relevant) versions of Windows.

#+BEGIN_SRC emacs-lisp
  (defun w32-maximize-frame ()
    "Maximize the current frame (windows only)"
    (interactive)
    (w32-send-sys-command 61488))
  (if (eq system-type 'windows-nt)
      (progn
        (add-hook 'window-setup-hook 'w32-maximize-frame t))
    (set-frame-parameter nil 'fullscreen 'maximized))
#+END_SRC

** Minimal GUI

Remove unnecessary GUI elements: menu-bar, tool-bar, and scroll-bar.

#+BEGIN_SRC emacs-lisp
  (if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
  (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
#+END_SRC

** No splash screen

Interesting trivia: Emacs originally opened to the scratch buffer by default.

#+BEGIN_SRC emacs-lisp
  (setq inhibit-splash-screen t)
#+END_SRC

** Initial scratch buffer message

#+BEGIN_SRC emacs-lisp
(setq initial-scratch-message "")
#+END_SRC

** Default Font

#+BEGIN_SRC emacs-lisp
  (add-to-list 'default-frame-alist '(font . "DejaVu Sans Mono-9" ))
  (set-face-attribute 'default t :font "DejaVu Sans Mono-9")
#+END_SRC

** STOP THE BEEPING AND FLASHING

#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function 'ignore)
#+END_SRC

** Theme

Monokai is warm and colorful. I set some variables so that text stays monospaced
and all the same size.

#+BEGIN_SRC emacs-lisp
  (use-package monokai-theme
    :init
    (setq monokai-use-variable-pitch nil
          monokai-height-minus-1 1.0
          monokai-height-plus-1 1.0
          monokai-height-plus-2 1.0
          monokai-height-plus-3 1.0
          monokai-height-plus-4 1.0)
    :config
    (load-theme 'monokai t))
#+END_SRC

** RainbowDelimiters

Highlight matching delimiters with unique colors. It's pretty indespensible
for lisp with all its mad parenthesis.

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :commands (rainbow-delimiters-mode)
    :init
    (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+END_SRC

** Highlight matching parenthesis
Specifically the ones under the cursor.

#+BEGIN_SRC emacs-lisp
  (custom-set-variables '(show-paren-delay 0.0))
  (show-paren-mode t)
#+END_SRC

** Highlight trailing white space

Trailing white space is something that you hate once you know it's there. Or at
least it is for me.

#+BEGIN_SRC emacs-lisp
  (custom-set-variables '(show-trailing-whitespace t))
  (custom-set-faces '(trailing-whitespace ((t (:background "dim gray")))))
#+END_SRC

** Prettify symbols

Convert certain words into symbols. Prime example: =lambda= becomes =λ=.

#+BEGIN_SRC emacs-lisp
(global-prettify-symbols-mode)
#+END_SRC

** Indicate lines after EOF

Use tildes like Vim :>

#+BEGIN_SRC emacs-lisp
  (define-fringe-bitmap 'tilde [0 0 0 113 219 142 0 0] nil nil 'center)
  (setcdr (assq 'empty-line fringe-indicator-alist) 'tilde)
  (set-fringe-bitmap-face 'tilde 'font-lock-comment-face)
  (setq-default indicate-empty-lines t)
#+END_SRC

** Show column number in modeline

#+BEGIN_SRC emacs-lisp
  (column-number-mode t)
#+END_SRC

** SmartModeLine

Mostly makes the mode line easier to read.

#+BEGIN_SRC emacs-lisp
  (use-package smart-mode-line
    :config
    (setq sml/no-confirm-load-theme t)
    (setq sml/theme 'dark)
    (sml/setup))
#+END_SRC

** Diminish

Use diminish to clean up the mode line. The mode line is cluttered as heck
without this. I use the =:diminish= key word for =use-package= when I can.

#+BEGIN_SRC emacs-lisp
  (use-package diminish
    :config
    (eval-after-load "hideshow" '(diminish 'hs-minor-mode))
    (eval-after-load "undo-tree" '(diminish 'undo-tree-mode))
    (eval-after-load "simple" '(diminish 'overwrite-mode))
    (eval-after-load "autorevert" '(diminish 'auto-revert-mode)))
#+END_SRC

* General settings

These settings don't belong to any specific mode or package. Some packages are
an exception for being very simple.

** Start server if it isn't started

Turn the first Emacs process into a server, which allows reuse of a that process
through the shell command =emacsclient=.

#+BEGIN_SRC emacs-lisp
  (require 'server)
  (if (not (server-running-p)) (server-start))
#+END_SRC

** Backup & auto-save files in one place

These files are useful if something goes wrong, but they're also annoying in how
they clutter directories. Put them in =~/.emacs.d/tmp= to remedy this.

#+BEGIN_SRC emacs-lisp
  (setq backup-directory-alist `((".*" . "~/.emacs.d/tmp"))
        auto-save-file-name-transforms `((".*" , "~/.emacs.d/tmp" t)))
#+END_SRC

** Scroll smoothly

#+BEGIN_SRC emacs-lisp
  (setq scroll-margin 0)
  (setq scroll-conservatively 10000)
  (setq scroll-preserve-screen-position t)
#+END_SRC

** Sentences end with a single period

#+BEGIN_SRC emacs-lisp
  (setq sentence-end-double-space nil)
#+END_SRC

** y/n instead of yes/no

#+BEGIN_SRC emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Wrap text at 80 characters

Part tradition, part totally sensible.

#+BEGIN_SRC emacs-lisp
  (setq-default fill-column 80)
#+END_SRC

** Indent with spaces by default

Tabs are weird and can have varying lengths, so I prefer spaces.

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
#+END_SRC

** Auto-detect indent settings

I prefer to follow a file's indenting style instead of enforcing my own, if
possible. =dtrt-indent= does this and works for most mainstream languages.

#+BEGIN_SRC emacs-lisp
  (use-package dtrt-indent)
#+END_SRC

** Auto-update changed files

If a file is changed outside of Emacs, automatically load those changes.

#+BEGIN_SRC emacs-lisp
  (global-auto-revert-mode t)
#+END_SRC

** Auto-executable scripts in *nix

When saving a file that starts with =#!=, make it executable.

#+BEGIN_SRC emacs-lisp
(add-hook 'after-save-hook
          'executable-make-buffer-file-executable-if-script-p)
#+END_SRC

** Enable HideShow in programming modes

Useful for getting an overview of the code. It works better in some
languages and layouts than others.

#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook (lambda () (hs-minor-mode t)))
#+END_SRC

** Enable recent files feature

#+BEGIN_SRC emacs-lisp
(recentf-mode 1)
#+END_SRC

** Better same-name buffer distinction

When two buffers are open with the same name, this makes it easier to tell them
apart.

#+BEGIN_SRC emacs-lisp
(require 'uniquify)
(setq uniquify-buffer-name-style 'forward)
#+END_SRC

** Remember last position for reopened files

#+BEGIN_SRC emacs-lisp
(if (version< emacs-version "25.0")
    (progn (require 'saveplace)
           (setq-default save-place t))
  (save-place-mode 1))
#+END_SRC

** Disable garbage collection in minibuffer

See [[http://tiny.cc/7wd7ay][this article]] for more info.

#+BEGIN_SRC emacs-lisp
(defun my-minibuffer-setup-hook ()
  (setq gc-cons-threshold most-positive-fixnum))
(defun my-minibuffer-exit-hook ()
  (setq gc-cons-threshold 800000))
(add-hook 'minibuffer-setup-hook #'my-minibuffer-setup-hook)
(add-hook 'minibuffer-exit-hook #'my-minibuffer-exit-hook)
#+END_SRC

* Key binding related

These are global bindings, and packages that affect key binding in general.

** Enhanced key binding

[[https://github.com/noctuid/general.el][general.el]] is one of my favorite packages, and makes it much nicer and easier to
bind keys. Particularly useful for Evil mode and its various states.

#+BEGIN_SRC emacs-lisp
(use-package general)
#+END_SRC

** Show available key bindings

Use =which-key= or =guide-key= to display key bindings. =which-key= is a
superior package, but isn't compatible with older versions of Emacs.

*** [[https://github.com/kai2nenobu/guide-key][guide-key]]:

#+BEGIN_SRC emacs-lisp
(if (version< emacs-version "24.4")
    (use-package guide-key
      :init
      (setq guide-key/guide-key-sequence t
            guide-key/recursive-key-sequence-flag t
            guide-key/popup-window-position 'bottom
            guide-key/idle-delay 0.5)
      :config
      (guide-key-mode 1))
#+END_SRC

*** [[https://github.com/justbur/emacs-which-key][which-key]]:

Show Evil-mode text objects and motions in the guide as well.

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :diminish ""
    :init
    (setq which-key-idle-delay 0.5
          which-key-side-window-max-height 0.50
          which-key-allow-evil-operators t
          which-key-show-operator-state-maps t))
    :config
    (which-key-mode)
    ;; show top-level bindings, I don't need the Emacs tutorial
    (general-define-key "C-h t" 'which-key-show-top-level))
#+END_SRC

** Resize text easier

Resize text like every other program does.

#+BEGIN_SRC emacs-lisp
(general-define-key
 "C-0" (lambda() (interactive) (text-scale-set 0))
 "C-=" 'text-scale-increase
 "C--" 'text-scale-decrease)
#+END_SRC

* Language-specific modes

** c-mode

My coding style preferences for C/C++:

#+BEGIN_SRC emacs-lisp
    (defun my-case-helper (sym-and-anchor)
      (let* ((new-offset '+) ; if there's nothing after the case colon, just indent by c-basic-offset
             (anchor (cdr sym-and-anchor))
             (anchor-line (line-number-at-pos anchor)))
        (save-excursion
          (goto-char anchor)
          (search-forward-regexp ":[[:space:]]*[^[:space:]{]" nil t)
          ;; did we find non-whitespace (and not just an open brace) after
          ;; the colon on the case line?
          (if (and (> (point) anchor)
                   (= anchor-line (line-number-at-pos)))
              (setq new-offset (- (point) anchor 1)))
          new-offset)))

    (c-add-style "my-style"
                 '("linux"
                   (c-offsets-alist
                    (statement-case-intro . my-case-helper))))

  (setq c-basic-offset 4
        c-default-style
        (quote
         ((c-mode . "my-style")
          (c++-mode . "my-style")
          (java-mode . "java")
          (awk-mode . "awk")
          (other . "gnu"))))

  (c-set-offset 'case-label '+)
#+END_SRC

* Setup various packages & modes

** Restart Emacs

Useful because I edit my config frequently

#+BEGIN_SRC emacs-lisp
  (use-package restart-emacs
    :commands (restart-emacs)
    :bind ("C-x C-r" . restart-emacs))
#+END_SRC

** Org-mode

*** Prettier bullets

Automatically hides preceding asterisks, and makes the leading one
pretty.

#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :commands (org-bullets-mode)
  :init
  (setq org-bullets-bullet-list '("●"))
  (add-hook 'org-mode-hook 'org-bullets-mode))
#+END_SRC

*** Noticeable ellipsis

When headers are collapsed, =org-mode= uses ellipses to represent the hidden
text, but I think that's too subtle, so this makes them stand out more.

#+BEGIN_SRC emacs-lisp
(setq org-ellipsis "•••")
#+END_SRC

*** Don't adapt indentation

The hierarchy of headers already does the job that indenting would do.

#+BEGIN_SRC emacs-lisp
(setq org-adapt-indentation nil)
#+END_SRC

*** utf-8 encoding plz

#+BEGIN_SRC emacs-lisp
(setq utf-translate-cjk-mode nil)
(set-locale-environment "pl_PL.UTF-8")
(set-language-environment 'utf-8)
(setq locale-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(unless (eq system-type 'windows-nt)
  (progn
    (set-selection-coding-system 'utf-8)
    (set-keyboard-coding-system 'utf-8-mac)))
(prefer-coding-system 'utf-8)
#+END_SRC

*** More convenient bindings

#+BEGIN_SRC emacs-lisp
  (general-define-key :keymaps 'org-mode-map
                      "C-c C-8" 'org-ctrl-c-star
                      "C-c 8" 'org-ctrl-c-star)
#+END_SRC

*** Global org bindings

These are available everywhere, even outside of org-mode.

#+BEGIN_SRC emacs-lisp
(global-set-key "\C-cl" 'org-store-link)
(global-set-key "\C-cc" 'org-capture)
(global-set-key "\C-ca" 'org-agenda)
(global-set-key "\C-cb" 'org-iswitchb)
#+END_SRC

*** [[*Evil Org][Evil-mode compatibility]]

** Dired

*** Enable find-alternate-file

Prevents dired from creating an annoying popup when =dired-find-alternate-file=
is called.

#+BEGIN_SRC emacs-lisp
(put 'dired-find-alternate-file 'disabled nil)
#+END_SRC

*** Human readable filesize

#+BEGIN_SRC emacs-lisp
(setq dired-listing-switches "-alh")
#+END_SRC

*** [[*Evil%20Dired][Evil-mode compatibility]]

** Magit

*** Install/activate

#+BEGIN_SRC emacs-lisp
  (use-package magit
    ;; Autoload related
    :commands (magit-status
               magit-diff
               magit-commit
               magit-log
               magit-push
               magit-stage-file
               magit-unstage-file))
#+END_SRC

*** Use =ssh-agency= for Windows login prompt

Windows has issues allowing Magit to display prompts (when pushing a repo, for
example), so this package deals with that and fixes it somehow.

#+BEGIN_SRC emacs-lisp
  (use-package ssh-agency
    :after (magit)
    :init
    (setenv "SSH_ASKPASS" "git-gui--askpass"))
#+END_SRC

*** [[*Evil%20Magit][Evil-mode compatibility]]

** Projectile

*** Install/activate

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    ;; Autoload related
    :commands (projectile-global-mode)
    :bind-keymap ("C-c p" . projectile-command-map)

    :config
    (projectile-mode t))
#+END_SRC

*** [[*Evil%20Projectile][Evil-mode compatibility]]

** Ivy

*** Install/activate

#+BEGIN_SRC emacs-lisp
    (use-package swiper
      ;; Autoload related
      :commands (ivy-read)
      :bind (("C-h f" . counsel-describe-function)
             ("C-h v" . counsel-describe-variable)
             ("C-s" . swiper))

      :init
      (setq ivy-use-virtual-buffers t)
      (setq ivy-wrap t)
      (setq magit-completing-read-function 'ivy-completing-read)
      (setq projectile-completion-system 'ivy)

      :config
      (ivy-mode 1)
      (diminish 'ivy-mode)

      (use-package counsel)
      (use-package ivy-hydra))
#+END_SRC

*** [[*Evil%20Ivy][Evil-mode compatibility]]

** Yasnippet

Snippets are located under the typical =~/.emacs.d/snippets=

#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :diminish yas-minor-mode
  :config
  (yas-global-mode 1))
#+END_SRC

* EVIL-MODE

Evil is so big and important that it gets its own top-level header. In all caps.

I used Vim for a couple years before Emacs (and still do), and that means I'm
cursed/blessed with modal editing for the rest of my life. Fortunately Evil is a
nearly exact Vim implementation, so all is well, and I can take advantage of
both editors with less mental strain.

** Compatibility with other modes

Create a list of functions to be ran when Evil-mode is activated. Each function
corresponds to a mode, and configures that mode to "be more evil."

The benefit of this is that I can enable or disable all of Evil-mode with a
single variable, and keep it untangled from all other packages/modes. I don't
know why I would ever want to disable Evil-mode, but I can if I want, I guess.

*** Related variables

#+BEGIN_SRC emacs-lisp
(setq my/evil-active t)
(setq my/evil-other-mode-funs ())
#+END_SRC

*** Evil Org

#+BEGIN_SRC emacs-lisp
  (defun setup-evil-org-mode ()
    (general-evil-define-key 'normal 'org-mode-map
      "RET" 'org-open-at-point
      ">>" 'outline-demote
      "<<" 'outline-promote
      "z j" 'outline-next-visible-heading
      "z k" 'outline-previous-visible-heading
      "z n" 'outline-next-heading
      "z p" 'outline-previous-heading
      "z u" 'outline-up-heading
      "z g" 'org-goto)
    (general-evil-define-key 'insert 'org-mode-map
      "C-t" 'outline-demote
      "C-d" 'outline-promote)
    (general-evil-define-key '(normal visual insert) 'org-mode-map
      "M-h" 'org-metaleft
      "M-j" 'org-metadown
      "M-k" 'org-metaup
      "M-l" 'org-metaright
      "M-S-h" 'org-shiftmetaleft
      "M-S-j" 'org-shiftmetadown
      "M-S-k" 'org-shiftmetaup
      "M-S-l" 'org-shiftmetaright
      "C-S-h" 'org-shiftcontrolleft
      "C-S-j" 'org-shiftcontroldown
      "C-S-k" 'org-shiftcontrolup
      "C-S-l" 'org-shiftcontrolright)

    (defun my/fix-org-evil-paragraphs ()
      "Make Evil mode's paragraph motions work correctly in Org mode."
      (setq paragraph-start "\\|[ 	]*$"
            paragraph-separate "[ 	]*$"))
    (add-hook 'org-mode-hook #'my/fix-org-evil-paragraphs))
  (add-to-list 'my/evil-other-mode-funs 'setup-evil-org-mode)
#+END_SRC

*** Evil Dired

Directory climbing inspired by [[https://github.com/tpope/vim-vinegar][tpope's vinegar]].

#+BEGIN_SRC emacs-lisp
  (defun setup-evil-dired-mode ()
    (with-eval-after-load "dired"
      (progn
        (evil-make-overriding-map dired-mode-map 'normal)
        (general-define-key :states 'normal "-" (kbd "C-x d RET"))
        (general-evil-define-key 'normal 'dired-mode-map
          "-" (lambda ()(interactive) (find-alternate-file ".."))
          "RET" 'dired-find-alternate-file
          "i" 'ido-find-file
          "j" 'dired-next-line
          "k" 'dired-previous-line))))
  (add-to-list 'my/evil-other-mode-funs 'setup-evil-dired-mode)
#+END_SRC

*** Evil Magit

#+BEGIN_SRC emacs-lisp
  (defun setup-evil-magit-mode ()
    (with-eval-after-load "magit"
      (progn
        (evil-set-initial-state 'magit-status-mode 'normal)
        (evil-set-initial-state 'magit-log-mode 'normal)
        (evil-set-initial-state 'magit-diff-mode 'normal)
        (evil-make-overriding-map magit-mode-map 'normal)
        (general-evil-define-key 'normal 'magit-mode-map
          "j" [down]
          "k" [up]
          "c" 'magit-commit-popup)
        (general-evil-define-key 'normal 'magit-diff-mode-map
          "C-j" 'evil-scroll-down)))

        ;; Leader shortcuts
        (general-define-key
         :states '(normal motion emacs)
         :prefix "SPC"
         "gs" 'magit-status
         "gd" 'magit-diff
         "gc" 'magit-commit
         "gl" 'magit-log
         "gp" 'magit-push
         "gw" 'magit-stage-file   ;; "write"
         "gr" 'magit-unstage-file ;; "remove"
         "gg" 'vc-git-grep))
  (add-to-list 'my/evil-other-mode-funs 'setup-evil-magit-mode)
#+END_SRC

*** Evil Projectile

#+BEGIN_SRC emacs-lisp
  (defun setup-evil-projectile-mode ()
    ;; Leader shortcuts
    (general-define-key
     :states '(normal motion emacs)
     :prefix "SPC"
     "p"  (general-simulate-keys "C-c p")))
  (add-to-list 'my/evil-other-mode-funs 'setup-evil-projectile-mode)
#+END_SRC

*** Evil Ivy

#+BEGIN_SRC emacs-lisp
  (defun setup-evil-ivy-mode ()
    (general-define-key
     :keymaps 'ivy-minibuffer-map
     "C-j" 'ivy-next-line
     "C-k" 'ivy-previous-line
     "C-n" 'ivy-next-history-element
     "C-p" 'ivy-previous-history-element
     "C-w" 'ivy-backward-kill-word)

    ;; Leader shortcuts
    (general-define-key
     :states '(normal motion emacs)
     :prefix "SPC"
     "SPC"  'counsel-M-x
     "b" 'ivy-switch-buffer
     "f" 'counsel-find-file
     "'" 'counsel-bookmark
     ))
  (add-to-list 'my/evil-other-mode-funs 'setup-evil-ivy-mode)
#+END_SRC

*** Evil Occur

#+BEGIN_SRC emacs-lisp
(defun setup-evil-occur-mode ()
  (evil-set-initial-state 'occur-mode 'normal)
  (evil-make-overriding-map occur-mode-map 'normal))
(add-to-list 'my/evil-other-mode-funs 'setup-evil-occur-mode)
#+END_SRC

*** Evil Bookmark

#+BEGIN_SRC emacs-lisp
  (defun setup-evil-bookmark-mode ()
    (with-eval-after-load "bookmark"
      (evil-set-initial-state 'bookmark-bmenu-mode 'normal)
      (evil-make-overriding-map bookmark-bmenu-mode-map 'normal)
      (general-evil-define-key 'normal 'bookmark-bmenu-mode-map
        "RET" 'bookmark-bmenu-this-window
        "j" 'evil-next-line
        "k" 'evil-previous-line)))
  (add-to-list 'my/evil-other-mode-funs 'setup-evil-bookmark-mode)
#+END_SRC

*** Evil Info

#+BEGIN_SRC emacs-lisp
  (defun setup-evil-info-mode ()
    (general-evil-define-key 'normal 'Info-mode-map
      "TAB" 'Info-next-reference
      "S-TAB" 'Info-prev-reference
      "RET" 'Info-follow-nearest-node
      "C-p" 'Info-history-back
      "C-n" 'Info-history-forward
      "q" 'Info-exit
      "u" 'Info-up
      "]" 'Info-forward-node
      "[" 'Info-backward-node
      ))
  (add-to-list 'my/evil-other-mode-funs 'setup-evil-info-mode)
#+END_SRC

*** Evil Help

#+BEGIN_SRC emacs-lisp
(defun setup-evil-help-mode ()
  (general-evil-define-key 'normal 'help-mode-map
    "q" 'quit-window
    "[" 'help-go-back
    "]" 'help-go-forward))
(add-to-list 'my/evil-other-mode-funs 'setup-evil-help-mode)
#+END_SRC

*** Evil Shell(s)

#+BEGIN_SRC emacs-lisp
(defun setup-evil-shell-mode ()
  (defun my/evil-shell-insert ()
    "Go to the very end of the buffer and enter insert state."
    (interactive)
    (evil-goto-line)
    (evil-append-line 0))
  (general-evil-define-key 'normal
      '(shell-mode-map eshell-mode-map term-mode-map)
    "I" 'my/evil-shell-insert
    "A" 'my/evil-shell-insert))
(add-to-list 'my/evil-other-mode-funs 'setup-evil-shell-mode)
#+END_SRC

*** Evil Ibuffer

#+BEGIN_SRC emacs-lisp
  (defun setup-evil-ibuffer-mode ()
    (with-eval-after-load "ibuffer"
      (progn
        (evil-set-initial-state 'ibuffer-mode 'normal)
        (evil-make-overriding-map ibuffer-mode-map 'normal))))
  (add-to-list 'my/evil-other-mode-funs 'setup-evil-ibuffer-mode)
#+END_SRC

** Custom/helper functions

*** [[https://github.com/mhinz/vim-sayonara][vim-sayonara]] inspired

I need to implement smarter logic for this. This is more of a place holder, really.

#+BEGIN_SRC emacs-lisp
(defun my/evil-sayonara ()
  "If there's one window, switch to next buffer. Otherwise, close the current
window."
  (interactive)
  (if (eq (next-window) (selected-window))
      (my/evil-sayonara-bang)
    (evil-window-delete)))

(defun my/evil-sayonara-bang ()
  "Switch to next buffer."
  (interactive)
  (next-buffer))
#+END_SRC

*** open init.el

Actually open *this* file you're reading, since it's functionally my =init.el=

#+BEGIN_SRC emacs-lisp
  (defun my/open-init-el ()
    (interactive)
    (find-file "~/.emacs.d/config.org"))
#+END_SRC

** START evil-setup function

The beginning of the function that runs after Evil-mode is activated, and
contains mostly all of my configuration for Evil.

#+BEGIN_SRC emacs-lisp
(defun setup-evil-settings ()
#+END_SRC

** General settings

*** Normal state == Motion state

Basically avoid Motion state and use Normal state instead. I don't really need
Motion state, so it add unnecessary complexity.

#+BEGIN_SRC emacs-lisp
(setq evil-normal-state-modes (append evil-motion-state-modes evil-normal-state-modes))
(setq evil-motion-state-modes nil)
#+END_SRC

*** Cursor color/shape to indicate modes/states

Match GVim's cursor shapes.

#+BEGIN_SRC emacs-lisp
  (setq evil-normal-state-cursor   '("dodger blue" box)
        evil-insert-state-cursor   '("dodger blue" bar)
        evil-replace-state-cursor  '("dodger blue" hbar)
        evil-operator-state-cursor '("dodger blue" (hbar . 7))
        evil-visual-state-cursor   '("orange" box)
        evil-motion-state-cursor   '("deep pink" box)
        evil-emacs-state-cursor    '("red2" box))
#+END_SRC

*** Auto-switch to help window like Vim

#+BEGIN_SRC emacs-lisp
(setq help-window-select t)
#+END_SRC

*** Center evil search & dehighlight when finished searching

#+BEGIN_SRC emacs-lisp
(defun my/evil-search-nohighlight-on-move ()
"Dehighlight Evil ex search when any keys other than n or N are pressed."
(interactive)
(if (not (or (equal (this-command-keys) "n")
                (equal (this-command-keys) "N")))
    (progn (evil-ex-nohighlight)
            (remove-hook 'pre-command-hook
                        'my/evil-search-nohighlight-on-move))))
(defun my/add-hook-evil-search ()
(add-hook 'pre-command-hook 'my/evil-search-nohighlight-on-move))
(defadvice evil-ex-start-search (after advice-for-evil-ex-start-search activate)
(progn (evil-scroll-line-to-center (line-number-at-pos))
        (my/add-hook-evil-search)))
(defadvice evil-ex-search (after advice-for-evil-ex-search activate)
(progn (evil-scroll-line-to-center (line-number-at-pos))
        (my/add-hook-evil-search)))
#+END_SRC

*** clear trailing whitespace ex command

#+BEGIN_SRC emacs-lisp
(evil-ex-define-cmd "ctw" 'delete-trailing-whitespace)
#+END_SRC

*** Re-enable evil-make-overriding/intercept-map

They were disabled before so that I can have complete control over key bindings.
They're being enabled again so that I can make use of them.

#+BEGIN_SRC emacs-lisp
(advice-remove 'evil-make-overriding-map #'my-kill-overriding-maps)
(advice-remove 'evil-make-intercept-map #'my-kill-intercept-maps)
#+END_SRC

** Global bindings

These are mostly remaps and convenience shortcuts for Evil mode.

*** Make defining bindings more vim-like with [[*Enhanced%20key%20binding][general.el]]

=nmap= looks so much nicer than =general-define-key :states 'normal=.

#+BEGIN_SRC emacs-lisp
  (general-evil-setup t 'current-global-map)
#+END_SRC

*** Just in case M-x is weirdly undefined

#+BEGIN_SRC emacs-lisp
  (nmap "M-x" 'execute-extended-command)
#+END_SRC

*** Back to last buffer

#+BEGIN_SRC emacs-lisp
  (nmap "DEL" 'evil-switch-to-windows-last-buffer)
#+END_SRC

*** U instead of C-r for redo

#+BEGIN_SRC emacs-lisp
  (nmap "U" 'redo)
#+END_SRC

*** Q to replay q register

#+BEGIN_SRC emacs-lisp
  (nmap "Q" "@q")
#+END_SRC

*** [S]plit Line (sister to [J]oin Line)

#+BEGIN_SRC emacs-lisp
  (defun my/split-line ()
  (interactive)
  (newline-and-indent) (forward-line -1) (move-end-of-line 1))
  (nmap "S" 'my/split-line )
#+END_SRC

*** =_= and =|= to split windows

also focus on the new split window like Vim

#+BEGIN_SRC emacs-lisp
  (defun evil-window-vsplit ()
  "Split current window vertically and focus on the new window."
  (interactive)
  (split-window-vertically)
  (other-window 1))
  (defun evil-window-split ()
  "Split current window horizontally and focus on the new window."
  (interactive)
  (split-window-horizontally)
  (other-window 1))
  (nmap "|" 'evil-window-split
        "_" 'evil-window-vsplit)
#+END_SRC

*** Convenient scrolling

Aside from being more comfortable, this keeps standard =C-u=
(universal-argument) available.

#+BEGIN_SRC emacs-lisp
  (nmap "C-j" 'evil-scroll-down
        "C-k" 'evil-scroll-up)
#+END_SRC

*** Jump list (previous, next)

#+BEGIN_SRC emacs-lisp
  (nmap "C-p" 'evil-jump-backward
        "C-n" 'evil-jump-forward)
#+END_SRC

*** select last pasted/changed text

#+BEGIN_SRC emacs-lisp
  (nmap "gp" (general-simulate-keys "` [ v ` ]"))
#+END_SRC

*** format last pasted/changed text

#+BEGIN_SRC emacs-lisp
  (nmap "g=" (general-simulate-keys "` [ v ` ] ="))
#+END_SRC

*** [g]o [s]ayonara

Inspired by [[https://github.com/mhinz/vim-sayonara][vim-sayonara]]

#+BEGIN_SRC emacs-lisp
  (nmap "gs" 'my/evil-sayonara
        "gS" 'my/evil-sayonara-bang)
#+END_SRC

*** evil-unimpaired

Inspired by [[https://github.com/tpope/vim-unimpaired][unimpaired]]:

#+BEGIN_SRC emacs-lisp
  (defun my/evil-blank-above (count)
    "Add [count] blank lines above the point."
    (interactive "p")
    (setq col (current-column))
    (while (> count 0)
      (evil-insert-newline-above)
      (forward-line 1)
      (add-hook 'post-command-hook #'evil-maybe-remove-spaces)
      (setq count (- count 1)))
    (move-to-column col))
  (defun my/evil-blank-below (count)
    "Add [count] blank lines below the point."
    (interactive "p")
    (setq col (current-column))
    (while (> count 0)
      (evil-insert-newline-below)
      (forward-line -1)
      (add-hook 'post-command-hook #'evil-maybe-remove-spaces)
      (setq count (- count 1)))
    (move-to-column col))
  (nmap "[ SPC" 'my/evil-blank-above
        "] SPC" 'my/evil-blank-below
        "[ b" 'previous-buffer
        "] b" 'next-buffer)
#+END_SRC

"change option" is the mnemonic:

#+BEGIN_SRC emacs-lisp
  (nmap "c" (general-key-dispatch 'evil-change
              "ot" 'toggle-truncate-lines
              "on" 'linum-mode
              "ow" 'toggle-word-wrap
              "oW" 'whitespace-mode
              ;; TODO: look into cross-platform spell checker
              "os" 'flyspell-mode
              "c" 'evil-change-whole-line
              "s" 'evil-surround-change
              ))
  ;; need this for c to work in visual mode
  (vmap "c" 'evil-change)
#+END_SRC

*** C-g to see total line numbers like Vim

#+BEGIN_SRC emacs-lisp
  (nmap "C-g" 'count-words)
#+END_SRC

*** Insert movement

#+BEGIN_SRC emacs-lisp
  (imap "C-a" 'move-beginning-of-line
        "C-e" 'move-end-of-line)
#+END_SRC

*** Always cancel/escape to normal state

#+BEGIN_SRC emacs-lisp
(general-define-key :states '(visual insert replace motion)
                    "C-g" 'evil-normal-state
                    "C-[" 'evil-normal-state)
#+END_SRC

*** "entire" text object (ae and ie)

For operating on the entire file.

#+BEGIN_SRC emacs-lisp
(load-file "~/.emacs.d/elisp/evil-textobj-entire.el")
#+END_SRC

** Leader bindings

The "leader" key is a concept from Vim, and it's just a global prefix key like
=C-x= or =C-c=, but for personal use. I use the spacebar as my leader key, and
[[https://github.com/noctuid/general.el][general.el]] to make it easy.

Other leader bindings may be defined for other packages under [[*Compatibility%20with%20other%20modes][their own
configuration]].

#+BEGIN_SRC emacs-lisp
  (general-define-key
   :states '(normal motion emacs)
   :prefix "SPC"

   ;;  Avoiding CTRL
   "w" 'evil-window-map
   "u" (general-simulate-keys "C-u")
   "x" (general-simulate-keys "C-x")
   "c" (general-simulate-keys "C-c")
   "h" (general-simulate-keys "C-h")

   ;; Often used shortcuts
   "TAB" 'other-window
   "s"  'evil-write
   "e"  'eval-last-sexp
   "q"  'quit-window
   "f"  'ido-find-file
   "b"  'ido-switch-buffer
   "B"  'ibuffer
   "m"  'bookmark-set
   "`"  'bookmark-bmenu-list
   "i"  'my/open-init-el)
#+END_SRC

** Run compatibility functions

Run a list of functions to make other modes "more evil." See [[Compatibility with
other modes]].

#+BEGIN_SRC emacs-lisp
(dolist (fun my/evil-other-mode-funs) (funcall fun))
#+END_SRC

** END evil-setup function

The end of the function that runs after Evil-mode is activated, and
contains mostly all of my configuration for Evil.

#+BEGIN_SRC emacs-lisp
)
#+END_SRC

** START use-package

The beginning of the =use-package= block for Evil.

#+BEGIN_SRC emacs-lisp
(if (eq my/evil-active t)
    (use-package evil
#+END_SRC

** Basic options

These need to be set before Evil-mode is activated.

#+BEGIN_SRC emacs-lisp
  :init
  ;; Pre-defined Evil options
  (setq evil-ex-substitute-global t
        evil-want-fine-undo "No"
        evil-want-Y-yank-to-eol t
        evil-overriding-maps nil
        evil-search-module 'evil-search)
#+END_SRC

** Disable evil-make-overriding/intercept-map at start-up.

Otherwise, Evil will mess with other mode's mappings. I want to mess with them
myself, instead.

#+BEGIN_SRC emacs-lisp
(advice-add 'evil-make-intercept-map
            :override (defun my-kill-intercept-maps (&rest _)))
(advice-add 'evil-make-overriding-map
            :override (defun my-kill-overriding-maps (&rest _)))
#+END_SRC

** Hook to configure Evil after activation

#+BEGIN_SRC emacs-lisp
:config
(add-hook 'evil-mode-hook 'setup-evil-settings)
#+END_SRC

** Evil-specific packages

These packages are installed/configured *after* Evil is loaded, but *before*
it's is activated. In my experience, this works well with all the Evil-related
packages I've used so far.

*** [[https://github.com/timcharper/evil-surround][evil-surround]]

Manipulate surroundings

#+BEGIN_SRC emacs-lisp
(use-package evil-surround
  :config
  (global-evil-surround-mode))
#+END_SRC

*** [[https://github.com/Dewdrops/evil-exchange][evil-exchange]]

Exchange operator

#+BEGIN_SRC emacs-lisp
(use-package evil-exchange
  :config
  ;; "[g]o e[x]change"
  ;; gX is cancel
  (evil-exchange-install))
#+END_SRC

*** [[https://github.com/redguardtoo/evil-nerd-commenter][evil-nerd-commenter]]

Comment operator

#+BEGIN_SRC emacs-lisp
(use-package evil-nerd-commenter
  :config
  (general-define-key :states '(normal visual) "gc"
  'evilnc-comment-operator))
#+END_SRC

*** [[https://github.com/bling/evil-visualstar][evil-visualstar]]

Make a visual selection, and search it. Convenient and intuitive.

#+BEGIN_SRC emacs-lisp
(use-package evil-visualstar
  :config
  (global-evil-visualstar-mode))
#+END_SRC

*** [[https://github.com/CodeFalling/nlinum-relative][nlinum-relative]]

Relative line numbers

#+BEGIN_SRC emacs-lisp
  (use-package nlinum-relative
    :init
    (setq nlinum-relative-current-symbol "->")
    :config
    (add-hook 'prog-mode-hook 'nlinum-relative-mode))
#+END_SRC

*** [[https://github.com/noctuid/emacs-sentence-navigation][emacs-sentence-navigation]]

#+BEGIN_SRC emacs-lisp
  (use-package sentence-navigation
    :config
    (define-key evil-normal-state-map ")" 'sentence-nav-evil-forward)
    (define-key evil-normal-state-map "(" 'sentence-nav-evil-backward)
    (define-key evil-normal-state-map "g)" 'sentence-nav-evil-forward-end)
    (define-key evil-normal-state-map "g(" 'sentence-nav-evil-backward-end)
    (define-key evil-outer-text-objects-map "s" 'sentence-nav-evil-outer-sentence)
    (define-key evil-inner-text-objects-map "s" 'sentence-nav-evil-inner-sentence)
    :defer t)
#+END_SRC

** END use-package

Activate Evil and finish the =use-package= block.

#+BEGIN_SRC emacs-lisp
      (evil-mode 1)))
#+END_SRC

